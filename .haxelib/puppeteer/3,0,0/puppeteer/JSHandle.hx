package puppeteer;

/**
	JSHandle represents an in-page JavaScript object.
**/
typedef JSHandle<T> = {
	/**
		Returns a ElementHandle
	**/
	function asElement():Null<ElementHandle<js.html.DOMElement>>;
	/**
		Stops referencing the element handle.
	**/
	function dispose():js.lib.Promise<Void>;
	/**
		Gets the execution context.
	**/
	function executionContext():ExecutionContext;
	/**
		Returns a map with property names as keys and JSHandle instances for the property values.
	**/
	function getProperties():js.lib.Promise<js.lib.Map<String, JSHandle<Dynamic>>>;
	/**
		Fetches a single property from the objectHandle.
	**/
	function getProperty(propertyName:String):js.lib.Promise<JSHandle<Dynamic>>;
	/**
		Returns a JSON representation of the object.
		The JSON is generated by running JSON.stringify on the object in page and consequent JSON.parse in puppeteer.
	**/
	function jsonValue():js.lib.Promise<Any>;
	/**
		Evaluates a function in the browser context.
		If the function, passed to the frame.evaluate, returns a Promise, then frame.evaluate would wait for the promise to resolve and return its value.
		If the function passed into frame.evaluate returns a non-Serializable value, then frame.evaluate resolves to undefined.
	**/
	function evaluate<T>(pageFunction:T, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<Dynamic>;
	/**
		The only difference between `evaluate` and `evaluateHandle` is that `evaluateHandle` returns in-page object (`JSHandle`).
		If the function, passed to the `evaluateHandle`, returns a `Promise`, then `evaluateHandle` would wait for the
		promise to resolve and return its value.
	**/
	function evaluateHandle(pageFunction:ts.AnyOf2<String, (arg1:T, args:haxe.extern.Rest<Dynamic>) -> Dynamic>, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<JSHandle<Dynamic>>;
};