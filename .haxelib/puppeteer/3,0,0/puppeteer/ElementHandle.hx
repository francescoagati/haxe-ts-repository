package puppeteer;

/**
	Represents an in-page DOM element. ElementHandles can be created with the page.$ method.
**/
typedef ElementHandle<E> = {
	/**
		The method runs element.querySelector within the page.
		If no element matches the selector, the return value resolve to null.
	**/
	@:native("$")
	function Dollar(selector:String):js.lib.Promise<Null<ElementHandle<js.html.DOMElement>>>;
	/**
		The method runs element.querySelectorAll within the page.
		If no elements match the selector, the return value resolve to [].
	**/
	@:native("$$")
	function DollarDollar(selector:String):js.lib.Promise<Array<ElementHandle<js.html.DOMElement>>>;
	@:native("$x")
	function DollarX(expression:String):js.lib.Promise<Array<ElementHandle<js.html.DOMElement>>>;
	/**
		This method returns the value resolve to the bounding box of the element (relative to the main frame), or null if the element is not visible.
	**/
	function boundingBox():js.lib.Promise<Null<BoundingBox>>;
	/**
		This method returns boxes of the element, or null if the element is not visible.
		Boxes are represented as an array of points; each Point is an object {x, y}. Box points are sorted clock-wise.
	**/
	function boxModel():js.lib.Promise<Null<BoxModel>>;
	/**
		This method scrolls element into view if needed, and then uses page.mouse to click in the center of the element.
		If the element is detached from DOM, the method throws an error.
	**/
	function click(?options:ClickOptions):js.lib.Promise<Void>;
	function contentFrame():js.lib.Promise<Null<Frame>>;
	/**
		Calls focus on the element.
	**/
	function focus():js.lib.Promise<Void>;
	/**
		This method scrolls element into view if needed, and then uses page.mouse to hover over the center of the element.
		If the element is detached from DOM, the method throws an error.
	**/
	function hover():js.lib.Promise<Void>;
	/**
		Resolves to true if the element is visible in the current viewport.
	**/
	function isIntersectingViewport():js.lib.Promise<Bool>;
	/**
		Focuses the element, and then uses keyboard.down and keyboard.up.
	**/
	function press(key:String, ?options:{ @:optional var text : String; @:optional var delay : Float; }):js.lib.Promise<Void>;
	/**
		This method scrolls element into view if needed, and then uses page.screenshot to take a screenshot of the element.
		If the element is detached from DOM, the method throws an error.
	**/
	@:overload(function(?options:BinaryScreenShotOptions):js.lib.Promise<global.Buffer> { })
	@:overload(function(?options:ScreenshotOptions):js.lib.Promise<ts.AnyOf2<String, global.Buffer>> { })
	function screenshot(?options:Base64ScreenShotOptions):js.lib.Promise<String>;
	/**
		Triggers a change and input event once all the provided options have been selected. If there's no <select> element
		matching selector, the method throws an error.
	**/
	function select(values:haxe.extern.Rest<String>):js.lib.Promise<Array<String>>;
	/**
		This method scrolls element into view if needed, and then uses touchscreen.tap to tap in the center of the element.
		If the element is detached from DOM, the method throws an error.
	**/
	function tap():js.lib.Promise<Void>;
	/**
		Returns a string representation of an object.
	**/
	function toString():String;
	/**
		Focuses the element, and then sends a keydown, keypress/input, and keyup event for each character in the text.
	**/
	function type(text:String, ?options:{ var delay : Float; }):js.lib.Promise<Void>;
	/**
		This method expects elementHandle to point to an input element.
	**/
	function uploadFile(filePaths:haxe.extern.Rest<String>):js.lib.Promise<Void>;
	/**
		Returns a ElementHandle
	**/
	function asElement():Null<ElementHandle<js.html.DOMElement>>;
	/**
		Stops referencing the element handle.
	**/
	function dispose():js.lib.Promise<Void>;
	/**
		Gets the execution context.
	**/
	function executionContext():ExecutionContext;
	/**
		Returns a map with property names as keys and JSHandle instances for the property values.
	**/
	function getProperties():js.lib.Promise<js.lib.Map<String, JSHandle<Dynamic>>>;
	/**
		Fetches a single property from the objectHandle.
	**/
	function getProperty(propertyName:String):js.lib.Promise<JSHandle<Dynamic>>;
	/**
		Returns a JSON representation of the object.
		The JSON is generated by running JSON.stringify on the object in page and consequent JSON.parse in puppeteer.
	**/
	function jsonValue():js.lib.Promise<Any>;
	/**
		Evaluates a function in the browser context.
		If the function, passed to the frame.evaluate, returns a Promise, then frame.evaluate would wait for the promise to resolve and return its value.
		If the function passed into frame.evaluate returns a non-Serializable value, then frame.evaluate resolves to undefined.
	**/
	function evaluate<T>(pageFunction:T, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<Dynamic>;
	/**
		The only difference between `evaluate` and `evaluateHandle` is that `evaluateHandle` returns in-page object (`JSHandle`).
		If the function, passed to the `evaluateHandle`, returns a `Promise`, then `evaluateHandle` would wait for the
		promise to resolve and return its value.
	**/
	function evaluateHandle(pageFunction:ts.AnyOf2<String, (arg1:E, args:haxe.extern.Rest<Dynamic>) -> Dynamic>, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<JSHandle<Dynamic>>;
	/**
		This method runs `document.querySelector` within the context and passes it as the first argument to `pageFunction`.
		If there's no element matching `selector`, the method throws an error.
		
		If `pageFunction` returns a Promise, then `$eval` would wait for the promise to resolve and return its value.
		
		This method runs `document.querySelector` within the context and passes it as the first argument to `pageFunction`.
		If there's no element matching `selector`, the method throws an error.
		
		If `pageFunction` returns a Promise, then `$eval` would wait for the promise to resolve and return its value.
		
		This method runs `document.querySelector` within the context and passes it as the first argument to `pageFunction`.
		If there's no element matching `selector`, the method throws an error.
		
		If `pageFunction` returns a Promise, then `$eval` would wait for the promise to resolve and return its value.
		
		This method runs `document.querySelector` within the context and passes it as the first argument to `pageFunction`.
		If there's no element matching `selector`, the method throws an error.
		
		If `pageFunction` returns a Promise, then `$eval` would wait for the promise to resolve and return its value.
		
		This method runs `document.querySelector` within the context and passes it as the first argument to `pageFunction`.
		If there's no element matching `selector`, the method throws an error.
		
		If `pageFunction` returns a Promise, then `$eval` would wait for the promise to resolve and return its value.
	**/
	@:native("$eval")
	@:overload(function<R, X1>(selector:String, pageFunction:(element:js.html.DOMElement, x1:UnwrapElementHandle<X1>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R, X1, X2>(selector:String, pageFunction:(element:js.html.DOMElement, x1:UnwrapElementHandle<X1>, x2:UnwrapElementHandle<X2>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1, x2:X2):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R, X1, X2, X3>(selector:String, pageFunction:(element:js.html.DOMElement, x1:UnwrapElementHandle<X1>, x2:UnwrapElementHandle<X2>, x3:UnwrapElementHandle<X3>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1, x2:X2, x3:X3):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R>(selector:String, pageFunction:(element:js.html.DOMElement, args:haxe.extern.Rest<Dynamic>) -> ts.AnyOf2<js.lib.Promise<R>, R>, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<WrapElementHandle<R>> { })
	function DollarEval<R>(selector:String, pageFunction:(element:js.html.DOMElement) -> ts.AnyOf2<js.lib.Promise<R>, R>):js.lib.Promise<WrapElementHandle<R>>;
	/**
		This method runs `Array.from(document.querySelectorAll(selector))` within the context and passes it as the
		first argument to `pageFunction`.
		
		If `pageFunction` returns a Promise, then `$$eval` would wait for the promise to resolve and return its value.
		
		This method runs `Array.from(document.querySelectorAll(selector))` within the context and passes it as the
		first argument to `pageFunction`.
		
		If `pageFunction` returns a Promise, then `$$eval` would wait for the promise to resolve and return its value.
		
		This method runs `Array.from(document.querySelectorAll(selector))` within the context and passes it as the
		first argument to `pageFunction`.
		
		If `pageFunction` returns a Promise, then `$$eval` would wait for the promise to resolve and return its value.
		
		This method runs `Array.from(document.querySelectorAll(selector))` within the context and passes it as the
		first argument to `pageFunction`.
		
		If `pageFunction` returns a Promise, then `$$eval` would wait for the promise to resolve and return its value.
		
		This method runs `Array.from(document.querySelectorAll(selector))` within the context and passes it as the
		first argument to `pageFunction`.
		
		If `pageFunction` returns a Promise, then `$$eval` would wait for the promise to resolve and return its value.
	**/
	@:native("$$eval")
	@:overload(function<R, X1>(selector:String, pageFunction:(elements:Array<js.html.DOMElement>, x1:UnwrapElementHandle<X1>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R, X1, X2>(selector:String, pageFunction:(elements:Array<js.html.DOMElement>, x1:UnwrapElementHandle<X1>, x2:UnwrapElementHandle<X2>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1, x2:X2):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R, X1, X2, X3>(selector:String, pageFunction:(elements:Array<js.html.DOMElement>, x1:UnwrapElementHandle<X1>, x2:UnwrapElementHandle<X2>, x3:UnwrapElementHandle<X3>) -> ts.AnyOf2<js.lib.Promise<R>, R>, x1:X1, x2:X2, x3:X3):js.lib.Promise<WrapElementHandle<R>> { })
	@:overload(function<R>(selector:String, pageFunction:(elements:Array<js.html.DOMElement>, args:haxe.extern.Rest<Dynamic>) -> ts.AnyOf2<js.lib.Promise<R>, R>, args:haxe.extern.Rest<SerializableOrJSHandle>):js.lib.Promise<WrapElementHandle<R>> { })
	function DollarDollarEval<R>(selector:String, pageFunction:(elements:Array<js.html.DOMElement>) -> ts.AnyOf2<js.lib.Promise<R>, R>):js.lib.Promise<WrapElementHandle<R>>;
};