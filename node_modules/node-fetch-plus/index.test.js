"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const nock_1 = __importDefault(require("nock"));
const fetch = __importStar(require("node-fetch"));
const node_fetch_1 = require("node-fetch");
const sinon_1 = __importDefault(require("sinon"));
const index_1 = __importDefault(require("./index"));
const testUrl = 'http://test.com';
const sandbox = sinon_1.default.createSandbox();
describe('NodeFetchToolkit', () => {
    before(() => {
        nock_1.default.disableNetConnect();
    });
    after(() => {
        nock_1.default.enableNetConnect();
    });
    afterEach(() => {
        nock_1.default.cleanAll();
        sandbox.restore();
    });
    describe('.fetch', () => {
        describe('node-fetch integration', () => {
            it('Delegates to node-fetch', () => __awaiter(this, void 0, void 0, function* () {
                const mockResponse = sandbox.mock();
                const client = new index_1.default();
                const fetchStub = sandbox.stub(fetch, 'default').resolves(mockResponse);
                const expectedUrl = `${testUrl}/path`;
                const expectedOpts = {
                    headers: {
                        'Test-Header': 'test-value',
                    },
                };
                const expectedRequest = new node_fetch_1.Request(expectedUrl);
                yield client.fetch(expectedUrl);
                yield client.fetch(expectedRequest);
                yield client.fetch(expectedUrl, expectedOpts);
                yield client.fetch(expectedRequest, expectedOpts);
                assert_1.default.strictEqual(fetchStub.getCalls().length, 4);
                sinon_1.default.assert.calledWith(fetchStub, expectedUrl);
                sinon_1.default.assert.calledWith(fetchStub, expectedRequest);
                sinon_1.default.assert.calledWith(fetchStub, expectedUrl, expectedOpts);
                sinon_1.default.assert.calledWith(fetchStub, expectedRequest, expectedOpts);
            }));
            it('returns the node-fetch response', () => __awaiter(this, void 0, void 0, function* () {
                const expectedResponse = sandbox.mock();
                const client = new index_1.default();
                sandbox.stub(fetch, 'default').resolves(expectedResponse);
                const actualResponse = yield client.fetch('http://any-url.com');
                assert_1.default.strictEqual(actualResponse, expectedResponse);
            }));
        });
        describe('retries', () => {
            it('can be configured to retry errors', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 2,
                    },
                });
                nock_1.default(testUrl)
                    .get('/path')
                    .twice()
                    .replyWithError(new Error('socket'));
                nock_1.default(testUrl)
                    .get('/path')
                    .reply(200);
                yield client.fetch('http://test.com/path');
                assert_1.default(nock_1.default.isDone(), `Expected 3 calls to ${testUrl}/path`);
            }));
            it('can be configured to retry any number of times', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 10,
                    },
                });
                nock_1.default(testUrl)
                    .get('/path')
                    .times(10)
                    .replyWithError(new Error('socket'));
                nock_1.default(testUrl)
                    .get('/path')
                    .reply(200);
                yield client.fetch('http://test.com/path');
                assert_1.default(nock_1.default.isDone(), `Expected 3 calls to ${testUrl}/path`);
            }));
            const retryOnStatusCodes = [408, 500, 502, 503, 504];
            for (const statusCode of retryOnStatusCodes) {
                it(`retries on status code ${statusCode} by default`, () => __awaiter(this, void 0, void 0, function* () {
                    const client = new index_1.default({
                        retry: {
                            factor: 0,
                            minTimeout: 1,
                            retries: 2,
                        },
                    });
                    const firstNock = nock_1.default(testUrl)
                        .get('/path')
                        .reply(statusCode);
                    const secondNock = nock_1.default(testUrl)
                        .get('/path')
                        .reply(200);
                    yield client.fetch('http://test.com/path');
                    assert_1.default(firstNock.isDone(), `Expected call to ${testUrl}/path`);
                    assert_1.default(secondNock.isDone(), `Expected second call to ${testUrl}/path`);
                }));
            }
            it('can be configured to retry on certain status codes', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 2,
                        retryOnStatusCodes: [418],
                    },
                });
                const firstNock = nock_1.default(testUrl)
                    .get('/path')
                    .reply(418);
                const secondNock = nock_1.default(testUrl)
                    .get('/path')
                    .reply(200);
                yield client.fetch('http://test.com/path');
                assert_1.default(firstNock.isDone(), `Expected call to ${testUrl}/path`);
                assert_1.default(secondNock.isDone(), `Expected second call to ${testUrl}/path`);
            }));
            it('can be configured to retry on multiple status codes', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 2,
                        retryOnStatusCodes: [408, 500, 504],
                    },
                });
                const firstNock = nock_1.default(testUrl)
                    .get('/path')
                    .reply(408);
                const secondNock = nock_1.default(testUrl)
                    .get('/path')
                    .reply(500);
                const thirdNock = nock_1.default(testUrl)
                    .get('/path')
                    .reply(504);
                const res = yield client.fetch('http://test.com/path');
                assert_1.default(firstNock.isDone(), `Expected call to ${testUrl}/path`);
                assert_1.default(secondNock.isDone(), `Expected second call to ${testUrl}/path`);
                assert_1.default(thirdNock.isDone(), `Expected second call to ${testUrl}/path`);
                assert_1.default.strictEqual(res.status, 504);
            }));
            it('returns the last response after failing to retry on a specific status code', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 2,
                        retryOnStatusCodes: [408],
                    },
                });
                nock_1.default(testUrl)
                    .get('/path')
                    .thrice()
                    .reply(408);
                const res = yield client.fetch('http://test.com/path');
                assert_1.default.strictEqual(res.status, 408);
            }));
            it('throws an error if all retries fail', () => __awaiter(this, void 0, void 0, function* () {
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 1,
                        retries: 2,
                    },
                });
                nock_1.default(testUrl)
                    .get('/path')
                    .times(3)
                    .replyWithError(new Error('socket'));
                return client.fetch('http://test.com/path').then(() => {
                    throw new Error('Expected error to be thrown but wasnt');
                }, (err) => {
                    assert_1.default(err, 'Expected an error but was not found');
                    assert_1.default(err.message.includes('socket'), `Expected message '${err.message}' to include 'socket'`);
                });
            }));
        });
        describe('events', () => {
            it("emits a 'request' event before attempting each request", () => __awaiter(this, void 0, void 0, function* () {
                nock_1.default(testUrl)
                    .delete('/path')
                    .reply(500);
                nock_1.default(testUrl)
                    .delete('/path')
                    .reply(200);
                const consoleStub = sandbox.stub(console, 'info');
                const fetchSpy = sandbox.spy(fetch, 'default');
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 0,
                        retries: 1,
                        retryOnStatusCodes: [500],
                    },
                });
                client.on('request', console.info);
                yield client.fetch('http://test.com/path', {
                    method: 'DELETE',
                });
                sinon_1.default.assert.callOrder(consoleStub, fetchSpy);
                sinon_1.default.assert.calledTwice(consoleStub);
                sinon_1.default.assert.calledWith(consoleStub, sinon_1.default.match({
                    attempt: 1,
                    maxAttempts: 2,
                    method: 'DELETE',
                    url: 'http://test.com/path',
                }));
                sinon_1.default.assert.calledWith(consoleStub, sinon_1.default.match({
                    attempt: 2,
                    maxAttempts: 2,
                    method: 'DELETE',
                    url: 'http://test.com/path',
                }));
            }));
            it("emits a 'response' event after it receives a successful response (i.e. not an error)", () => __awaiter(this, void 0, void 0, function* () {
                nock_1.default(testUrl)
                    .delete('/path')
                    .reply(500);
                nock_1.default(testUrl)
                    .delete('/path')
                    .reply(200);
                const consoleStub = sandbox.stub(console, 'info');
                const fetchSpy = sandbox.spy(fetch, 'default');
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 0,
                        retries: 1,
                        retryOnStatusCodes: [500],
                    },
                });
                client.on('response', console.info);
                yield client.fetch('http://test.com/path', {
                    method: 'DELETE',
                });
                sinon_1.default.assert.callOrder(consoleStub, fetchSpy);
                sinon_1.default.assert.calledTwice(consoleStub);
                sinon_1.default.assert.calledWith(consoleStub, sinon_1.default.match({
                    attempt: 1,
                    maxAttempts: 2,
                    method: 'DELETE',
                    responseTime: sinon_1.default.match.number,
                    statusCode: 500,
                    url: 'http://test.com/path',
                }));
                sinon_1.default.assert.calledWith(consoleStub, sinon_1.default.match({
                    attempt: 2,
                    maxAttempts: 2,
                    method: 'DELETE',
                    responseTime: sinon_1.default.match.number,
                    statusCode: 200,
                    url: 'http://test.com/path',
                }));
            }));
            it("emits an 'error' event after it receives an error", () => __awaiter(this, void 0, void 0, function* () {
                nock_1.default(testUrl)
                    .delete('/path')
                    .replyWithError(new Error('BOOM!'));
                nock_1.default(testUrl)
                    .delete('/path')
                    .reply(200);
                const consoleStub = sandbox.stub(console, 'info');
                const fetchSpy = sandbox.spy(fetch, 'default');
                const client = new index_1.default({
                    retry: {
                        factor: 0,
                        minTimeout: 0,
                        retries: 1,
                    },
                });
                client.on('error', console.info);
                yield client.fetch('http://test.com/path', {
                    method: 'DELETE',
                });
                sinon_1.default.assert.callOrder(consoleStub, fetchSpy);
                sinon_1.default.assert.calledOnce(consoleStub);
                sinon_1.default.assert.calledWith(consoleStub, sinon_1.default.match({
                    attempt: 1,
                    maxAttempts: 2,
                    message: 'request to http://test.com/path failed, reason: BOOM!',
                    method: 'DELETE',
                    responseTime: sinon_1.default.match.number,
                    url: 'http://test.com/path',
                }));
            }));
        });
    });
});
