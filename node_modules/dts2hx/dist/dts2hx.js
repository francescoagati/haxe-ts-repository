// Generated by Haxe 4.0.5
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var js_node_ChildProcess = require("child_process");
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var v = parseInt(x, (x[(i + 1)]=="x" || x[(i + 1)]=="X") ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var Sys = function() { };
Sys.__name__ = true;
Sys.environment = function() {
	var m = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(process.env);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		var v = process.env[key];
		if(__map_reserved[key] != null) {
			m.setReserved(key,v);
		} else {
			m.h[key] = v;
		}
	}
	return m;
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var Console = function() { };
Console.__name__ = true;
Console.format = function(s,formatMode) {
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var escaped = e.matched(1) != null;
		if(escaped) {
			return e.matched(0);
		}
		var open = e.matched(2) == null;
		var tags = e.matched(3).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var last = activeFormatFlagStack[activeFormatFlagStack.length - 1];
				var i = activeFormatFlagStack.indexOf(last);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(_$Console_FormatFlag_$Impl_$.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = _$Console_FormatFlag_$Impl_$.fromString(tags[0]);
				if(flag != null) {
					var i1 = activeFormatFlagStack.indexOf(flag);
					if(i1 != -1) {
						var proceedingTags1 = groupedProceedingTags[i1];
						activeFormatFlagStack.splice(i1 - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i1 - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		} else {
			var proceedingTags2 = 0;
			var _g = 0;
			while(_g < tags.length) {
				var tag = tags[_g];
				++_g;
				var flag1 = _$Console_FormatFlag_$Impl_$.fromString(tag);
				if(flag1 == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag1);
					groupedProceedingTags.push(proceedingTags2);
					++proceedingTags2;
				} else {
					var i2 = activeFormatFlagStack.indexOf(flag1);
					if(i2 != -1) {
						var proceedingTags3 = groupedProceedingTags[i2];
						activeFormatFlagStack.splice(i2 - proceedingTags3,proceedingTags3 + 1);
						groupedProceedingTags.splice(i2 - proceedingTags3,proceedingTags3 + 1);
					}
				}
			}
		}
		switch(formatMode) {
		case 0:
			if(open) {
				if(activeFormatFlagStack.length > 0) {
					var lastFlagCount = groupedProceedingTags[groupedProceedingTags.length - 1] + 1;
					var asciiFormatString = "";
					var _g1 = 0;
					var _g11 = lastFlagCount;
					while(_g1 < _g11) {
						var i3 = _g1++;
						var idx = groupedProceedingTags.length - 1 - i3;
						asciiFormatString += Console.getAsciiFormat(activeFormatFlagStack[idx]);
					}
					return asciiFormatString;
				} else {
					return "";
				}
			} else {
				var result1 = Console.getAsciiFormat("reset");
				var result2 = new Array(activeFormatFlagStack.length);
				var _g2 = 0;
				var _g12 = activeFormatFlagStack.length;
				while(_g2 < _g12) {
					var i4 = _g2++;
					result2[i4] = Console.getAsciiFormat(activeFormatFlagStack[i4]);
				}
				var _g3 = [];
				var _g13 = 0;
				var _g21 = result2;
				while(_g13 < _g21.length) {
					var v = _g21[_g13];
					++_g13;
					if(v != null) {
						_g3.push(v);
					}
				}
				return result1 + _g3.join("");
			}
			break;
		case 1:
			var result3 = new Array(activeFormatFlagStack.length);
			var _g4 = 0;
			var _g14 = activeFormatFlagStack.length;
			while(_g4 < _g14) {
				var i5 = _g4++;
				result3[i5] = Console.getBrowserFormat(activeFormatFlagStack[i5]);
			}
			var _g5 = [];
			var _g15 = 0;
			var _g22 = result3;
			while(_g15 < _g22.length) {
				var v1 = _g22[_g15];
				++_g15;
				if(v1 != null) {
					_g5.push(v1);
				}
			}
			var result4 = _g5.join(";");
			browserFormatArguments.push(result4);
			return "%c";
		case 2:
			return "";
		}
	});
	return { formatted : result, browserFormatArguments : browserFormatArguments};
};
Console.stripFormatting = function(s) {
	return Console.format(s,2).formatted;
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	var result = Console.format(s,Console.formatMode);
	if(Console.formatMode == 1) {
		var logArgs = [result.formatted].concat(result.browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result.formatted,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	if(Console.printIntercept != null) {
		var allowDefaultPrint = Console.printIntercept(s,outputStream);
		if(!allowDefaultPrint) {
			return;
		}
	}
	if(Console.unicodeCompatibilityMode == 1 && !Console.unicodeCompatibilityEnabled) {
		Console.exec("chcp 65001");
		Console.unicodeCompatibilityEnabled = true;
	}
	switch(outputStream) {
	case 1:case 2:
		new _$Sys_FileOutput(2).writeString(s);
		break;
	case 0:case 3:
		new _$Sys_FileOutput(1).writeString(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[38;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex1 = HxOverrides.substr(flag,3,null);
		var r1 = Std.parseInt("0x" + HxOverrides.substr(hex1,0,2));
		var g1 = Std.parseInt("0x" + HxOverrides.substr(hex1,2,2));
		var b1 = Std.parseInt("0x" + HxOverrides.substr(hex1,4,2));
		return "\x1B[48;5;" + Console.rgbToAscii256(r1,g1,b1) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return "";
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var ier = Math.abs(r - colorSteps[ir]);
	var ieg = Math.abs(g - colorSteps[ig]);
	var ieb = Math.abs(b - colorSteps[ib]);
	var averageColorError = ier + ieg + ieb;
	var jr = Math.round((r - 8) / 10);
	var jg = Math.round((g - 8) / 10);
	var jb = Math.round((b - 8) / 10);
	var jer = Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8));
	var jeg = Math.abs(g - Math.max(Math.min(jg * 10 + 8,238),8));
	var jeb = Math.abs(b - Math.max(Math.min(jb * 10 + 8,238),8));
	var averageGrayError = jer + jeg + jeb;
	if(averageGrayError < averageColorError && r == g && g == b) {
		var grayIndex = jr + 232;
		return grayIndex;
	} else {
		var colorIndex = 16 + ir * 36 + ig * 6 + ib;
		return colorIndex;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof(window) != "undefined";
	if(hasWindowObject) {
		return 1;
	}
	var tputColors = Console.exec("tput colors");
	if(tputColors.exit == 0) {
		var tputResult = Std.parseInt(tputColors.stdout);
		if(tputResult != null && tputResult > 2) {
			return 0;
		}
	}
	var _this = Sys.environment();
	var termEnv = __map_reserved["TERM"] != null ? _this.getReserved("TERM") : _this.h["TERM"];
	if(termEnv != null && new EReg("cygwin|xterm|vt100","").match(termEnv)) {
		return 0;
	}
	return 2;
};
Console.exec = function(cmd,args) {
	var p = js_node_ChildProcess.spawnSync(cmd,args != null ? args : [],{ });
	var stdout = p.stdout == null ? "" : p.stdout.toString();
	if(stdout == null) {
		stdout = "";
	}
	return { exit : p.status, stdout : stdout};
};
var _$Console_FormatFlag_$Impl_$ = {};
_$Console_FormatFlag_$Impl_$.__name__ = true;
_$Console_FormatFlag_$Impl_$.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var ConverterContext = $hx_exports["ConverterContext"] = function(inputModuleName,moduleSearchPath,compilerOptions,locationComments) {
	this._rasterizeMappedTypes = true;
	this._currentTypeStack = [];
	this.typeStackLimit = 25;
	this.enableTypeParameterConstraints = false;
	this.shortenTypePaths = true;
	this.declarationSymbolQueue = new ds_OnceOnlySymbolQueue();
	this.generatedModules = new haxe_ds_StringMap();
	var _gthis = this;
	var s = Console.logPrefix + ("" + Std.string("Converting module <b>" + inputModuleName + "</b>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	this.host = ts.createCompilerHost(compilerOptions);
	this.locationComments = locationComments;
	var moduleName = inputModuleName;
	if(tool_TsProgramTools.isDirectPathReferenceModule(moduleName)) {
		moduleName = TsInternal.convertToRelativePath(moduleName,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName)));
	}
	StringTools.replace(moduleName,"\\","/");
	var moduleNameParts = moduleName.split("/");
	if(moduleNameParts[0] == "@types" && moduleNameParts.length > 1) {
		moduleNameParts.shift();
	}
	this.normalizedInputModuleName = moduleNameParts.join("/");
	var result = ts.resolveModuleName(inputModuleName,moduleSearchPath + "/.",compilerOptions,this.host);
	if(result.resolvedModule == null) {
		var failedLookupLocations = Reflect.field(result,"failedLookupLocations");
		Log.error("Failed to find typescript for module <b>\"" + inputModuleName + "\"</b>. Searched the following paths:<dim>\n\t" + failedLookupLocations.join("\n\t") + "</>");
		throw new js__$Boot_HaxeError("Input module not resolved");
	}
	this.entryPointModule = result.resolvedModule;
	var packageRootModule;
	if(this.entryPointModule.packageId != null) {
		var moduleName1 = this.entryPointModule.packageId.name;
		if(tool_TsProgramTools.isDirectPathReferenceModule(moduleName1)) {
			moduleName1 = TsInternal.convertToRelativePath(moduleName1,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName)));
		}
		StringTools.replace(moduleName1,"\\","/");
		var moduleNameParts1 = moduleName1.split("/");
		if(moduleNameParts1[0] == "@types" && moduleNameParts1.length > 1) {
			moduleNameParts1.shift();
		}
		this.packageName = moduleNameParts1.join("/");
		if(this.entryPointModule.packageId.name != inputModuleName) {
			var result1 = ts.resolveModuleName(this.packageName,moduleSearchPath + "/.",compilerOptions,this.host);
			if(result1.resolvedModule == null) {
				var failedLookupLocations1 = Reflect.field(result1,"failedLookupLocations");
				Log.error("Root package for <b>" + inputModuleName + "</> was <b>" + this.packageName + "</> but this module could not be resolved. Searched the following paths:<dim>\n\t" + failedLookupLocations1.join("\n\t") + "</>");
			}
			packageRootModule = result1.resolvedModule;
		} else {
			packageRootModule = this.entryPointModule;
		}
	} else {
		packageRootModule = null;
	}
	var inputSourcePaths = [this.entryPointModule.resolvedFileName];
	if(packageRootModule != null) {
		inputSourcePaths.unshift(packageRootModule.resolvedFileName);
	}
	this.program = ts.createProgram(inputSourcePaths,compilerOptions,this.host);
	this.tc = this.program.getTypeChecker();
	Log.diagnostics(null,tool_TsProgramTools.getAllDiagnostics(this.program));
	var entryPointSourceFile = this.program.getSourceFile(this.entryPointModule.resolvedFileName);
	var packageRootSourceFile = packageRootModule != null ? this.program.getSourceFile(packageRootModule.resolvedFileName) : null;
	if(entryPointSourceFile == null) {
		throw new js__$Boot_HaxeError("Failed to get entry-point source file");
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this.program.getSourceFiles();
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v.hasNoDefaultLib) {
			_g.push(v);
		}
	}
	var defaultLibSourceFiles = _g;
	var dependencyRootSourceFiles = [];
	var dependencyModuleNames = [];
	this.moduleDependencies = dependencyModuleNames;
	entryPointSourceFile.moduleName = this.normalizedInputModuleName;
	if(packageRootSourceFile != null) {
		packageRootSourceFile.moduleName = this.packageName;
	}
	var moduleReferences = tool_TsProgramTools.resolveAllTypeReferenceDirectives(this.program,this.host);
	var _g3 = 0;
	while(_g3 < moduleReferences.length) {
		var moduleReference = moduleReferences[_g3];
		++_g3;
		if(moduleReference.resolvedTypeReferenceDirective != null) {
			var resolvedFileName = moduleReference.resolvedTypeReferenceDirective.resolvedFileName;
			var packageInfo = moduleReference.resolvedTypeReferenceDirective.packageId;
			var moduleName2 = packageInfo != null ? packageInfo.name : null;
			if(moduleName2 == null) {
				Log.warn("Referenced module does not have a moduleName in packageInfo <b>" + resolvedFileName + "</>");
			}
			var sourceFile = resolvedFileName != null ? this.program.getSourceFile(resolvedFileName) : null;
			if(sourceFile != null) {
				var tmp;
				if(moduleName2 != null) {
					var moduleName3 = moduleName2;
					if(tool_TsProgramTools.isDirectPathReferenceModule(moduleName3)) {
						moduleName3 = TsInternal.convertToRelativePath(moduleName3,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName)));
					}
					StringTools.replace(moduleName3,"\\","/");
					var moduleNameParts2 = moduleName3.split("/");
					if(moduleNameParts2[0] == "@types" && moduleNameParts2.length > 1) {
						moduleNameParts2.shift();
					}
					tmp = moduleNameParts2.join("/");
				} else {
					tmp = null;
				}
				sourceFile.moduleName = tmp;
				dependencyRootSourceFiles.push(sourceFile);
				if(moduleName2 != null) {
					dependencyModuleNames.push(moduleName2);
				}
			} else {
				Log.error("Internal error: failed get source file for file <b>\"" + resolvedFileName + "\"</> (module: <b>\"" + moduleName2 + "\"</>)");
			}
		} else {
			Log.error("Failed to find referenced module <b>" + moduleReference.failedLookupLocations[0] + "</b>");
		}
	}
	var accessRoots = [];
	if(packageRootSourceFile != null) {
		accessRoots.push(packageRootSourceFile);
	}
	accessRoots.push(entryPointSourceFile);
	accessRoots = accessRoots.concat(defaultLibSourceFiles).concat(dependencyRootSourceFiles);
	this.symbolAccessMap = new SymbolAccessMap(this.program,accessRoots);
	this.haxeTypePathMap = new HaxeTypePathMap(this.packageName != null ? this.packageName : this.normalizedInputModuleName,this.program,this.symbolAccessMap);
	tool_TsProgramTools.walkReferencedSourceFiles(this.program,entryPointSourceFile,function(sourceFile1) {
		var _g11 = 0;
		var _g21 = tool_TsProgramTools.getExposedSymbolsOfSourceFile(_gthis.program,sourceFile1);
		while(_g11 < _g21.length) {
			var symbol = _g21[_g11];
			++_g11;
			tool_TsSymbolTools.walkDeclarationSymbols(_gthis.tc,symbol,function(symbol1,access) {
				return _gthis.declarationSymbolQueue.tryEnqueue(symbol1);
			});
		}
		return;
	});
	while(!this.declarationSymbolQueue.empty()) {
		var symbol2 = this.declarationSymbolQueue.dequeue();
		var _g12 = 0;
		var _g22 = this.symbolAccessMap.getAccess(symbol2);
		while(_g12 < _g22.length) {
			var access1 = _g22[_g12];
			++_g12;
			if(ConverterContext.isHaxeModuleSource(this.tc,symbol2)) {
				this.generateHaxeModulesFromSymbol(symbol2,access1);
			}
			if(ConverterContext.isGlobalField(this.tc,symbol2,access1)) {
				var globalModule = SupportTypes.getGlobalModuleForFieldSymbol(this,symbol2,access1);
				var field = this.fieldFromSymbol(symbol2.name,symbol2,SymbolAccess.Global([]),null);
				tool_HaxeTools.enableAccess(field,haxe_macro_Access.AStatic);
				globalModule.fields.push(field);
			}
		}
	}
	var _g13 = new haxe_iterators_MapKeyValueIterator(this.generatedModules);
	while(_g13.hasNext()) {
		var _g23 = _g13.next();
		var _ = _g23.key;
		var hxModule = _g23.value;
		tool_HaxeTools.resolveNameCollisions(hxModule.fields);
	}
};
ConverterContext.__name__ = true;
ConverterContext.isHaxeModuleSource = function(tc,symbol) {
	if((symbol.flags & (ts.SymbolFlags.Type | ts.SymbolFlags.ValueModule)) == 0) {
		return tool_TsSymbolTools.isConstructorTypeVariableSymbol(tc,symbol);
	} else {
		return true;
	}
};
ConverterContext.requiresHxClass = function(tc,symbol) {
	if((symbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.ValueModule)) == 0) {
		return tool_TsSymbolTools.isConstructorTypeVariableSymbol(tc,symbol);
	} else {
		return true;
	}
};
ConverterContext.requiresAdditionalStructureType = function(tc,symbol) {
	if((symbol.flags & ts.SymbolFlags.Interface) != 0) {
		return ConverterContext.requiresHxClass(tc,symbol);
	} else {
		return false;
	}
};
ConverterContext.isGlobalField = function(tc,symbol,access) {
	if(access._hx_index == 2) {
		var _g = access.symbolChain;
		if(_g.length == 1) {
			var _g1 = _g[0];
			if((symbol.flags & (ts.SymbolFlags.Variable | ts.SymbolFlags.Function)) != 0 && !tool_TsSymbolTools.isConstructorTypeVariableSymbol(tc,symbol)) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
};
ConverterContext.prototype = {
	getReferencedHaxeTypePath: function(symbol,accessContext,preferInterfaceStructure) {
		var hxTypePath = this.haxeTypePathMap.getTypePath(symbol,accessContext,preferInterfaceStructure);
		if(!hxTypePath.isExistingStdLibType) {
			this.declarationSymbolQueue.tryEnqueue(symbol);
		}
		var noPack;
		if(this.shortenTypePaths) {
			var accessSymbolChain = tool_SymbolAccessTools.extractSymbolChain(accessContext);
			var lastAccessSymbol = accessSymbolChain[accessSymbolChain.length - 1];
			if(lastAccessSymbol != null) {
				var contextTypePath = this.haxeTypePathMap.getTypePath(lastAccessSymbol,accessContext,false);
				noPack = contextTypePath.pack.join(".") == hxTypePath.pack.join(".");
			} else {
				noPack = false;
			}
		} else {
			noPack = false;
		}
		return { name : hxTypePath.name, pack : noPack ? [] : hxTypePath.pack};
	}
	,getGeneratedModule: function(typePath) {
		var this1 = this.generatedModules;
		var key = this.getHaxeModuleKey(typePath.pack,typePath.name);
		var _this = this1;
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
	,generateHaxeModulesFromSymbol: function(symbol,access) {
		var _gthis = this;
		var pos = tool_TsSymbolTools.getPosition(symbol);
		var isConstructorTypeVariable = tool_TsSymbolTools.isConstructorTypeVariableSymbol(this.tc,symbol);
		var isValueModuleOnlySymbol = (symbol.flags & ts.SymbolFlags.ValueModule) != 0 && (symbol.flags & ts.SymbolFlags.Type) == 0 && !isConstructorTypeVariable;
		var fundamentalTypePath = this.haxeTypePathMap.getTypePath(symbol,access,false);
		if(!fundamentalTypePath.isExistingStdLibType) {
			var hxModule;
			if((symbol.flags & ts.SymbolFlags.Enum) != 0) {
				var isCompileTimeEnum = (symbol.flags & ts.SymbolFlags.ConstEnum) != 0;
				var hxEnumType = this.complexTypeBaseOfEnumSymbol(symbol);
				var _g = [];
				var _g1 = 0;
				var _g2 = this.tc.getExportsOfModule(symbol);
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if((v.flags & ts.SymbolFlags.EnumMember) != 0) {
						_g.push(v);
					}
				}
				var enumMembers = _g;
				var _g3 = [];
				var _g11 = 0;
				while(_g11 < enumMembers.length) {
					var enumMember = enumMembers[_g11];
					++_g11;
					_g3.push(this.fieldFromSymbol(enumMember.name,enumMember,access,null));
				}
				var hxEnumFields = _g3;
				hxModule = { pack : fundamentalTypePath.pack, name : fundamentalTypePath.name, kind : haxe_macro_TypeDefKind.TDAbstract(hxEnumType,[hxEnumType],[hxEnumType]), params : [], isExtern : true, fields : hxEnumFields, doc : this.getDoc(symbol), meta : (isCompileTimeEnum ? [] : [tool_SymbolAccessTools.toAccessMetadata(access)]).concat([{ name : ":enum", pos : pos}]), pos : pos, tsSymbol : symbol, tsSymbolAccess : access};
			} else if((symbol.flags & ts.SymbolFlags.TypeAlias) != 0) {
				var _g4 = [];
				var _g12 = 0;
				var _g21 = tool_TsSymbolTools.getDeclarationsArray(symbol);
				while(_g12 < _g21.length) {
					var v1 = _g21[_g12];
					++_g12;
					if(v1.kind == ts.SyntaxKind.TypeAliasDeclaration) {
						_g4.push(v1);
					}
				}
				var typeAliasDeclaration = _g4[0];
				if(typeAliasDeclaration == null) {
					Log.warn("TypeAlias symbol did not have a TypeAliasDeclaration",null,symbol);
				}
				var tsType = this.tc.getDeclaredTypeOfSymbol(symbol);
				var hxAliasType = this.complexTypeFromTsType(tsType,access,typeAliasDeclaration,false);
				var forceAbstractKind = (symbol.flags & ts.SymbolFlags.ValueModule) != 0 || isConstructorTypeVariable;
				var hxTypeDef = forceAbstractKind ? { pack : fundamentalTypePath.pack, name : fundamentalTypePath.name, fields : [], kind : haxe_macro_TypeDefKind.TDAbstract(hxAliasType,[hxAliasType],[hxAliasType]), params : this.typeParamDeclFromTypeDeclarationSymbol(symbol,access,typeAliasDeclaration), doc : this.getDoc(symbol), isExtern : true, meta : [tool_SymbolAccessTools.toAccessMetadata(access),{ name : ":forward", pos : pos},{ name : ":forwardStatics", pos : pos}], pos : pos, tsSymbol : symbol, tsSymbolAccess : access} : { pack : fundamentalTypePath.pack, name : fundamentalTypePath.name, fields : [], kind : haxe_macro_TypeDefKind.TDAlias(hxAliasType), params : this.typeParamDeclFromTypeDeclarationSymbol(symbol,access,typeAliasDeclaration), doc : this.getDoc(symbol), pos : pos, tsSymbol : symbol, tsSymbolAccess : access};
				hxModule = hxTypeDef;
			} else if(ConverterContext.requiresHxClass(this.tc,symbol)) {
				var classDeclaration = Lambda.find(symbol.declarations,function(d) {
					return d.kind == ts.SyntaxKind.ClassDeclaration;
				});
				var declaration;
				if(classDeclaration != null) {
					declaration = classDeclaration;
				} else if(symbol.valueDeclaration != null) {
					declaration = symbol.valueDeclaration;
				} else {
					Log.error("Expected valueDeclaration for a symbol that requires a class in haxe",null,symbol);
					declaration = null;
				}
				var declaredType = this.tc.getDeclaredTypeOfSymbol(symbol);
				var meta = [tool_SymbolAccessTools.toAccessMetadata(access)];
				var superClassPath = null;
				if(isValueModuleOnlySymbol) {
					meta.push({ name : "valueModuleOnly", pos : pos});
				}
				var callSignatures = this.tc.getSignaturesOfType(declaredType,ts.SignatureKind.Call);
				var indexSignatures = tool_TsTypeTools.getIndexSignaturesOfType(this.tc,declaredType);
				var _g5 = [];
				var _g13 = 0;
				var _g22 = this.tc.getPropertiesOfType(declaredType);
				while(_g13 < _g22.length) {
					var v2 = _g22[_g13];
					++_g13;
					if(tool_TsSymbolTools.isAccessibleField(v2)) {
						_g5.push(v2);
					}
				}
				var classMembers = _g5;
				var classSuperType = tool_TsSymbolTools.getClassExtendsType(this.tc,symbol);
				if(classSuperType != null) {
					var hxSuperType = this.complexTypeFromObjectType(classSuperType,access,false,declaration);
					if(hxSuperType._hx_index == 0) {
						var p = hxSuperType.p;
						superClassPath = p;
					} else {
						Log.error("Class super-type did not translate to a class-path");
						superClassPath = null;
					}
					var _g6 = [];
					var _g14 = 0;
					var _g23 = this.tc.getPropertiesOfType(classSuperType);
					while(_g14 < _g23.length) {
						var v3 = _g23[_g14];
						++_g14;
						if(tool_TsSymbolTools.isAccessibleField(v3)) {
							_g6.push(v3);
						}
					}
					var classSuperMembers = _g6;
					var _g7 = [];
					var _g15 = 0;
					var _g24 = classMembers;
					while(_g15 < _g24.length) {
						var v4 = _g24[_g15];
						++_g15;
						var m = [v4];
						var classSuperMatch = Lambda.find(classSuperMembers,(function(m1) {
							return function(sm) {
								return sm.name == m1[0].name;
							};
						})(m));
						var classMembers1;
						if(classSuperMatch != null) {
							if((m[0].flags & ts.SymbolFlags.Method) != 0) {
								var format = ts.TypeFormatFlags.NoTruncation;
								classMembers1 = _gthis.tc.typeToString(_gthis.getTsTypeOfField(m[0]),m[0].valueDeclaration,format) != _gthis.tc.typeToString(_gthis.getTsTypeOfField(classSuperMatch),classSuperMatch.valueDeclaration,format);
							} else {
								classMembers1 = false;
							}
						} else {
							classMembers1 = true;
						}
						if(classMembers1) {
							_g7.push(v4);
						}
					}
					classMembers = _g7;
				}
				var fields = this.generateTypeFields(symbol,access,declaration,tool_TsSymbolTools.getConstructorSignatures(symbol,this.tc),callSignatures,indexSignatures,classMembers);
				tool_HaxeTools.resolveNameCollisions(fields);
				hxModule = { pack : fundamentalTypePath.pack, name : fundamentalTypePath.name, fields : fields, kind : haxe_macro_TypeDefKind.TDClass(superClassPath,[],false,false), params : this.typeParamDeclFromTypeDeclarationSymbol(symbol,access,declaration), isExtern : true, doc : this.getDoc(symbol), meta : meta, pos : pos, tsSymbol : symbol, tsSymbolAccess : access};
			} else if((symbol.flags & ts.SymbolFlags.Interface) != 0) {
				hxModule = this.createInterfaceModule(symbol,access,false);
			} else {
				Log.error("generateHaxeModulesFromSymbol(): Unhandled symbol, no flags were recognized",null,symbol);
				var fundamentalTypePath1 = fundamentalTypePath.pack;
				var fundamentalTypePath2 = fundamentalTypePath.name;
				var hxModule1 = this.getDoc(symbol);
				hxModule = { pack : fundamentalTypePath1, name : fundamentalTypePath2, fields : [], kind : haxe_macro_TypeDefKind.TDAbstract(haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []}),[haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []})],[haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []})]), doc : hxModule1, isExtern : true, pos : pos, tsSymbol : symbol, tsSymbolAccess : access};
			}
			if(isConstructorTypeVariable) {
				var constructorTypeDeclaration = symbol.valueDeclaration;
				if(constructorTypeDeclaration != null) {
					var constructorType = this.tc.getTypeOfSymbolAtLocation(symbol,constructorTypeDeclaration);
					var constructSignatures = this.tc.getSignaturesOfType(constructorType,ts.SignatureKind.Construct);
					var callSignatures1 = this.tc.getSignaturesOfType(constructorType,ts.SignatureKind.Call);
					var indexSignatures1 = tool_TsTypeTools.getIndexSignaturesOfType(this.tc,constructorType);
					var _g8 = [];
					var _g16 = 0;
					var _g25 = this.tc.getPropertiesOfType(constructorType);
					while(_g16 < _g25.length) {
						var v5 = _g25[_g16];
						++_g16;
						if(tool_TsSymbolTools.isAccessibleField(v5)) {
							_g8.push(v5);
						}
					}
					var fields1 = _g8;
					if(indexSignatures1.length > 0) {
						Log.warn("Index signatures are not yet supported",null,symbol);
					}
					var newField = this.newFieldFromSignatures(constructSignatures,access,constructorTypeDeclaration);
					hxModule.fields.unshift(newField);
					if(callSignatures1.length > 0) {
						var callField = this.functionFieldFromCallSignatures(ConverterContext.selfCallFunctionName,callSignatures1,access,constructorTypeDeclaration);
						tool_HaxeTools.enableAccess(callField,haxe_macro_Access.AStatic);
						hxModule.fields.push(callField);
					}
					var _g9 = 0;
					while(_g9 < fields1.length) {
						var field = fields1[_g9];
						++_g9;
						var hxField = this.fieldFromSymbol(field.name,field,access,constructorTypeDeclaration);
						tool_HaxeTools.enableAccess(hxField,haxe_macro_Access.AStatic);
						hxModule.fields.push(hxField);
					}
				} else {
					Log.error("A symbol with a constructor type variable declaration should have a valueDeclaration",null,symbol);
				}
			}
			var _g10 = 0;
			var _g17 = [];
			var _g18 = 0;
			var _g26 = tool_TsSymbolTools.getExports(symbol);
			while(_g18 < _g26.length) {
				var v6 = _g26[_g18];
				++_g18;
				if((v6.flags & ts.SymbolFlags.ClassMember) != 0 && tool_TsSymbolTools.isAccessibleField(v6)) {
					_g17.push(v6);
				}
			}
			var _g19 = _g17;
			while(_g10 < _g19.length) {
				var staticClassMember = _g19[_g10];
				++_g10;
				var field1 = this.fieldFromSymbol(staticClassMember.name,staticClassMember,access,null);
				tool_HaxeTools.enableAccess(field1,haxe_macro_Access.AStatic);
				hxModule.fields.push(field1);
			}
			if((symbol.flags & ts.SymbolFlags.Module) != 0) {
				var _g20 = [];
				var _g110 = 0;
				var _g27 = this.tc.getExportsOfModule(symbol);
				while(_g110 < _g27.length) {
					var v7 = _g27[_g110];
					++_g110;
					if((v7.flags & ts.SymbolFlags.ModuleMember) != 0 && (tool_TsSymbolTools.isAccessibleField(v7) || (v7.flags & ts.SymbolFlags.Alias) != 0)) {
						_g20.push(v7);
					}
				}
				var moduleMemberFields = _g20;
				var _g28 = 0;
				while(_g28 < moduleMemberFields.length) {
					var moduleMember = moduleMemberFields[_g28];
					++_g28;
					var nativeFieldName = moduleMember.name;
					if((moduleMember.flags & ts.SymbolFlags.Alias) != 0) {
						moduleMember = this.tc.getAliasedSymbol(moduleMember);
						if(!tool_TsSymbolTools.isAccessibleField(moduleMember)) {
							continue;
						}
					}
					if(tool_TsSymbolTools.isConstructorTypeVariableSymbol(this.tc,moduleMember)) {
						continue;
					}
					var field2 = this.fieldFromSymbol(nativeFieldName,moduleMember,access,null);
					tool_HaxeTools.enableAccess(field2,haxe_macro_Access.AStatic);
					hxModule.fields.push(field2);
				}
			}
			this.saveHaxeModule(hxModule);
		}
		if(ConverterContext.requiresAdditionalStructureType(this.tc,symbol)) {
			this.saveHaxeModule(this.createInterfaceModule(symbol,access,true));
		}
	}
	,createInterfaceModule: function(symbol,access,preferInterfaceStructure) {
		var pos = tool_TsSymbolTools.getPosition(symbol);
		var typePath = this.haxeTypePathMap.getTypePath(symbol,access,preferInterfaceStructure);
		var declaration = Lambda.find(symbol.declarations,function(d) {
			return d.kind == ts.SyntaxKind.InterfaceDeclaration;
		});
		var declaredType = this.tc.getDeclaredTypeOfSymbol(symbol);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.tc.getPropertiesOfType(declaredType);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(tool_TsSymbolTools.isAccessibleField(v)) {
				_g.push(v);
			}
		}
		var declaredMembers = _g;
		var fields = this.generateTypeFields(symbol,access,declaration,[],this.tc.getSignaturesOfType(declaredType,ts.SignatureKind.Call),tool_TsTypeTools.getIndexSignaturesOfType(this.tc,declaredType),declaredMembers);
		var _g3 = 0;
		while(_g3 < fields.length) {
			var field = fields[_g3];
			++_g3;
			if(field.access != null) {
				var _g4 = [];
				var _g11 = 0;
				var _g21 = field.access;
				while(_g11 < _g21.length) {
					var v1 = _g21[_g11];
					++_g11;
					if(v1._hx_index == 7) {
						_g4.push(v1);
					}
				}
				field.access = _g4;
			}
		}
		tool_HaxeTools.resolveNameCollisions(fields);
		return { pack : typePath.pack, name : typePath.name, fields : [], kind : haxe_macro_TypeDefKind.TDAlias(haxe_macro_ComplexType.TAnonymous(fields)), params : this.typeParamDeclFromTypeDeclarationSymbol(symbol,access,declaration), isExtern : false, doc : this.getDoc(symbol), meta : [], pos : pos, tsSymbol : symbol, tsSymbolAccess : access};
	}
	,generateTypeFields: function(symbol,access,declaration,constructorSignatures,callSignatures,indexSignatures,classMembers) {
		var fields = [];
		if(constructorSignatures.length > 0) {
			fields.push(this.newFieldFromSignatures(constructorSignatures,access,declaration));
		}
		if(callSignatures.length > 0) {
			fields.push(this.functionFieldFromCallSignatures(ConverterContext.selfCallFunctionName,callSignatures,access,declaration));
		}
		if(indexSignatures.length > 0) {
			Log.warn("Index signatures are not yet supported",null,symbol);
		}
		var _g = 0;
		while(_g < classMembers.length) {
			var classMember = classMembers[_g];
			++_g;
			fields.push(this.fieldFromSymbol(classMember.name,classMember,access,declaration));
		}
		return fields;
	}
	,isTypeStructureInHaxe: function(type,accessContext,enclosingDeclaration) {
		if((type.flags & ts.TypeFlags.Object) != 0) {
			if(this.isHxAny(this.complexTypeFromTsType(type,accessContext,enclosingDeclaration))) {
				return false;
			}
			var objectType = type;
			var isAnonType = (objectType.objectFlags & ts.ObjectFlags.Anonymous) != 0;
			var isInterface = (type.symbol.flags & ts.SymbolFlags.Interface) != 0;
			var isValueModule = (type.symbol.flags & ts.SymbolFlags.ValueModule) != 0;
			var isConstructorType = tool_TsTypeTools.isConstructorType(this.tc,objectType);
			var appearsToBeStructure = !isConstructorType && !isValueModule && (isAnonType || isInterface);
			var appearsToBeStructure1 = appearsToBeStructure;
			return appearsToBeStructure;
		} else {
			return false;
		}
	}
	,getHaxeModuleKey: function(pack,name) {
		var _this = pack.concat([name]);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].toLowerCase();
		}
		return result.join("/");
	}
	,saveHaxeModule: function($module) {
		var path = this.getHaxeModuleKey($module.pack,$module.name);
		var _this = this.generatedModules;
		var existingModule = __map_reserved[path] != null ? _this.getReserved(path) : _this.h[path];
		if(existingModule != null) {
			Log.warn("<red><b>saveHaxeModule():</> Module <b>\"" + path + "\"</> has already been generated once and will be overwritten</>");
		}
		var _this1 = this.generatedModules;
		if(__map_reserved[path] != null ? _this1.existsReserved(path) : _this1.h.hasOwnProperty(path)) {
			debugger;
		}
		var _this2 = this.generatedModules;
		if(__map_reserved[path] != null) {
			_this2.setReserved(path,$module);
		} else {
			_this2.h[path] = $module;
		}
	}
	,getDoc: function(symbol) {
		var sourceLocationInfo = [];
		if(this.locationComments) {
			var node = symbol.valueDeclaration != null ? symbol.valueDeclaration : tool_TsSymbolTools.getDeclarationsArray(symbol)[0];
			if(node != null) {
				var sourceFile = node.getSourceFile();
				if(sourceFile != null) {
					var start = node.getStart();
					var lineAndCharacter = sourceFile.getLineAndCharacterOfPosition(start);
					var line = lineAndCharacter.line;
					var character = lineAndCharacter.character;
					sourceLocationInfo.push("" + TsInternal.convertToRelativePath(sourceFile.fileName,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName))) + ":" + (line + 1) + (character > 0 ? ":" + (character + 1) : ""));
				}
			}
		}
		var _this = symbol.getDocumentationComment(this.tc);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = StringTools.trim(_this[i].text);
		}
		return result.concat(sourceLocationInfo).join("\n");
	}
	,complexTypeFromTsType: function(type,accessContext,enclosingDeclaration,allowAlias,preferInterfaceStructure) {
		if(preferInterfaceStructure == null) {
			preferInterfaceStructure = false;
		}
		if(allowAlias == null) {
			allowAlias = true;
		}
		var _gthis = this;
		if(tool_TsTypeTools.isThisType(type)) {
			var thisTarget = tool_TsTypeTools.getThisTypeTarget(type);
			if(thisTarget != null) {
				type = thisTarget;
			}
		}
		if(this._currentTypeStack.length >= this.typeStackLimit) {
			Log.error("Internal error: Reached type-depth limit, stopping further type conversions. This indicates unbound recursive type conversion");
			debugger;
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
		var stackHasType = Lambda.has(this._currentTypeStack,type);
		if(allowAlias && type.aliasSymbol != null) {
			this._currentTypeStack.push(type);
			var isAliasToMappedType = (type.flags & ts.TypeFlags.Object) != 0 && (type.objectFlags & ts.ObjectFlags.Mapped) != 0;
			var hxType;
			if(isAliasToMappedType && this._rasterizeMappedTypes && !stackHasType) {
				this._rasterizeMappedTypes = false;
				var t = this.complexTypeAnonFromTsType(type,accessContext,enclosingDeclaration);
				this._rasterizeMappedTypes = true;
				hxType = t;
			} else {
				var haxeTypePath = this.getReferencedHaxeTypePath(type.aliasSymbol,accessContext,preferInterfaceStructure);
				var params;
				if(type.aliasTypeArguments != null) {
					var _this = type.aliasTypeArguments;
					var result = new Array(_this.length);
					var _g = 0;
					var _g1 = _this.length;
					while(_g < _g1) {
						var i = _g++;
						result[i] = haxe_macro_TypeParam.TPType(_gthis.complexTypeFromTsType(_this[i],accessContext,enclosingDeclaration));
					}
					params = result;
				} else {
					params = [];
				}
				hxType = haxe_macro_ComplexType.TPath({ pack : haxeTypePath.pack, name : haxeTypePath.name, params : params});
			}
			this._currentTypeStack.pop();
			return hxType;
		}
		if(stackHasType) {
			Log.log("Breaking recursive type conversion",null,null,type);
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
		this._currentTypeStack.push(type);
		var complexType;
		try {
			if((type.flags & ts.TypeFlags.Any) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
			} else if((type.flags & (ts.TypeFlags.Unknown | ts.TypeFlags.Never)) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []});
			} else if((type.flags & ts.TypeFlags.String) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "String", params : []});
			} else if((type.flags & ts.TypeFlags.Number) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Float", params : []});
			} else if((type.flags & ts.TypeFlags.Boolean) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Bool", params : []});
			} else if((type.flags & ts.TypeFlags.Undefined) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Null", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
			} else if((type.flags & ts.TypeFlags.Void) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Void", params : []});
			} else if((type.flags & ts.TypeFlags.Enum) != 0) {
				var hxTypePath = this.getReferencedHaxeTypePath(type.symbol,accessContext,false);
				complexType = haxe_macro_ComplexType.TPath(hxTypePath);
			} else if((type.flags & ts.TypeFlags.Union) != 0) {
				complexType = this.complexTypeFromUnionType(type,accessContext,enclosingDeclaration);
			} else if((type.flags & ts.TypeFlags.Intersection) != 0) {
				complexType = this.complexTypeFromIntersectionType(type,accessContext,enclosingDeclaration);
			} else if((type.flags & ts.TypeFlags.StringLiteral) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "String", params : []});
			} else if((type.flags & ts.TypeFlags.NumberLiteral) != 0) {
				var numberLiteral = type;
				var value = numberLiteral.value;
				var isInt = (value | 0) == value;
				complexType = isInt ? haxe_macro_ComplexType.TPath({ pack : [], name : "Int", params : []}) : haxe_macro_ComplexType.TPath({ pack : [], name : "Float", params : []});
			} else if((type.flags & ts.TypeFlags.BooleanLiteral) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Bool", params : []});
			} else if((type.flags & ts.TypeFlags.TypeParameter) != 0) {
				complexType = this.complexTypeFromTypeParameter(type,accessContext,enclosingDeclaration);
			} else if((type.flags & ts.TypeFlags.Object) != 0) {
				complexType = this.complexTypeFromObjectType(type,accessContext,preferInterfaceStructure,enclosingDeclaration);
			} else if((type.flags & ts.TypeFlags.ESSymbolLike) != 0) {
				complexType = haxe_macro_ComplexType.TPath({ pack : ["js","lib"], name : "Symbol", params : []});
			} else if((type.flags & ts.TypeFlags.BigInt) != 0) {
				complexType = this.complexTypeFromTsType(this.tc.getApparentType(type),accessContext,enclosingDeclaration);
			} else {
				Log.warn("Type not yet supported",null,null,type);
				complexType = haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
			}
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			debugger;
			this._currentTypeStack.pop();
			throw js__$Boot_HaxeError.wrap(e1);
		}
		this._currentTypeStack.pop();
		return complexType;
	}
	,complexTypeFromUnionType: function(unionType,accessContext,enclosingDeclaration) {
		var _gthis = this;
		var _g = [];
		var _g1 = 0;
		var _g2 = unionType.types;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if((v.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) == 0) {
				_g.push(v);
			}
		}
		var typesWithoutNullable = _g;
		var nullable = typesWithoutNullable.length != unionType.types.length;
		var result = new Array(typesWithoutNullable.length);
		var _g3 = 0;
		var _g11 = typesWithoutNullable.length;
		while(_g3 < _g11) {
			var i = _g3++;
			result[i] = _gthis.complexTypeFromTsType(typesWithoutNullable[i],accessContext,enclosingDeclaration);
		}
		var hxTypes = tool_HaxeTools.deduplicateTypes(result);
		if(!nullable && Lambda.exists(hxTypes,function(t) {
			return _gthis.isHxAny(t);
		})) {
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
		var unionType1;
		switch(hxTypes.length) {
		case 0:
			unionType1 = haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
			break;
		case 1:
			unionType1 = hxTypes[0];
			break;
		default:
			unionType1 = SupportTypes.getUnionType(this,hxTypes);
		}
		if(nullable) {
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Null", params : [haxe_macro_TypeParam.TPType(unionType1)]});
		} else {
			return unionType1;
		}
	}
	,complexTypeFromIntersectionType: function(intersectionType,accessContext,enclosingDeclaration) {
		var _gthis = this;
		var types = intersectionType.types;
		var hasNonStructureType = Lambda.exists(types,function(t) {
			return !_gthis.isTypeStructureInHaxe(t,accessContext,enclosingDeclaration);
		});
		var nativelyIntersectable = !hasNonStructureType;
		if(nativelyIntersectable) {
			var result = new Array(types.length);
			var _g = 0;
			var _g1 = types.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _gthis.complexTypeAnonFromTsType(types[i],accessContext,enclosingDeclaration);
			}
			var hxAnonTypes = tool_HaxeTools.deduplicateTypes(result);
			var seenFieldNames = new haxe_ds_StringMap();
			var selfCallFields = 0;
			var _g2 = 0;
			while(_g2 < hxAnonTypes.length) {
				var hxAnonType = hxAnonTypes[_g2];
				++_g2;
				if(nativelyIntersectable) {
					if(hxAnonType._hx_index == 2) {
						var fields = hxAnonType.fields;
						var nameClash = false;
						var _g3 = 0;
						while(_g3 < fields.length) {
							var field = fields[_g3];
							++_g3;
							if(tool_HaxeTools.getMeta(field,":selfCall") != null) {
								++selfCallFields;
							} else {
								var nativeName = tool_HaxeTools.getNativeName(field);
								if(__map_reserved[nativeName] != null ? seenFieldNames.existsReserved(nativeName) : seenFieldNames.h.hasOwnProperty(nativeName)) {
									nameClash = true;
									break;
								}
								if(__map_reserved[nativeName] != null) {
									seenFieldNames.setReserved(nativeName,true);
								} else {
									seenFieldNames.h[nativeName] = true;
								}
							}
						}
						nativelyIntersectable = !nameClash;
					} else {
						nativelyIntersectable = false;
					}
				} else {
					nativelyIntersectable = false;
				}
				if(selfCallFields > 1) {
					nativelyIntersectable = false;
				}
				if(!nativelyIntersectable) {
					break;
				}
			}
		}
		if(nativelyIntersectable) {
			var accessSymbolChain = tool_SymbolAccessTools.extractSymbolChain(accessContext);
			var accessModuleSymbol = accessSymbolChain[accessSymbolChain.length - 1];
			var selfReferencedType = accessModuleSymbol != null ? Lambda.find(types,function(t1) {
				if(t1.symbol != accessModuleSymbol) {
					return t1.aliasSymbol == accessModuleSymbol;
				} else {
					return true;
				}
			}) : null;
			if(selfReferencedType != null) {
				Log.warn("Recursive intersections are not supported (haxe issue #9397); some type information will be lost",null,null,intersectionType);
				return this.complexTypeFromTsType(selfReferencedType,accessContext,enclosingDeclaration);
			} else {
				var result1 = new Array(types.length);
				var _g4 = 0;
				var _g11 = types.length;
				while(_g4 < _g11) {
					var i1 = _g4++;
					result1[i1] = _gthis.complexTypeFromTsType(types[i1],accessContext,enclosingDeclaration,null,true);
				}
				var hxTypes = tool_HaxeTools.deduplicateTypes(result1);
				return haxe_macro_ComplexType.TIntersection(hxTypes);
			}
		} else {
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
	}
	,complexTypeFromTypeParameter: function(typeParameter,accessContext,enclosingDeclaration) {
		if(typeParameter.symbol != null) {
			var thisTarget = tool_TsTypeTools.getThisTypeTarget(typeParameter);
			if(tool_TsTypeTools.isThisType(typeParameter) && thisTarget != null) {
				return this.complexTypeFromTsType(thisTarget,accessContext,enclosingDeclaration);
			} else {
				return haxe_macro_ComplexType.TPath({ name : tool_HaxeTools.toSafeTypeName(typeParameter.symbol.name), pack : []});
			}
		} else {
			Log.error("Internal error: Failed to determine type parameter name, using `T`",null,null,typeParameter);
			return haxe_macro_ComplexType.TPath({ pack : [], name : "T", params : []});
		}
	}
	,complexTypeFromObjectType: function(objectType,accessContext,preferInterfaceStructure,enclosingDeclaration) {
		if((objectType.objectFlags & ts.ObjectFlags.Reference) != 0) {
			return this.complexTypeFromTypeReference(objectType,accessContext,preferInterfaceStructure,enclosingDeclaration);
		} else if((objectType.objectFlags & ts.ObjectFlags.ClassOrInterface) != 0) {
			return this.complexTypeFromInterfaceType(objectType,accessContext,preferInterfaceStructure,enclosingDeclaration);
		} else if((objectType.objectFlags & ts.ObjectFlags.Anonymous) != 0) {
			return this.complexTypeAnonFromTsType(objectType,accessContext,enclosingDeclaration);
		} else {
			Log.warn("Could not convert object type <b>" + Std.string(tool_TsTypeTools.getObjectFlagsInfo(objectType)) + "</b> " + objectType.objectFlags,null,null,objectType);
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
	}
	,complexTypeAnonFromTsType: function(tsType,accessContext,enclosingDeclaration) {
		var _gthis = this;
		if((tsType.flags & ts.TypeFlags.TypeParameter) != 0) {
			Log.warn("Cannot get anon type from type parameter",null,null,tsType);
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.tc.getPropertiesOfType(tsType);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(tool_TsSymbolTools.isAccessibleField(v)) {
				_g.push(v);
			}
		}
		var typeFields = _g;
		var callSignatures = tsType.getCallSignatures();
		var constructSignatures = tsType.getConstructSignatures();
		if(tsType.getConstructSignatures().length > 0) {
			Log.warn("Type has construct signature but this is currently unhandled",null,null,tsType);
		}
		if(callSignatures.length == 1 && constructSignatures.length == 0 && typeFields.length == 0) {
			return this.complexTypeFromCallSignature(tsType.getCallSignatures()[0],accessContext,enclosingDeclaration);
		} else {
			var fields = [];
			if(callSignatures.length > 0) {
				fields.push(this.functionFieldFromCallSignatures(ConverterContext.selfCallFunctionName,callSignatures,accessContext,enclosingDeclaration));
			}
			var result = new Array(typeFields.length);
			var _g3 = 0;
			var _g11 = typeFields.length;
			while(_g3 < _g11) {
				var i = _g3++;
				var p = typeFields[i];
				result[i] = _gthis.fieldFromSymbol(p.name,p,accessContext,enclosingDeclaration);
			}
			fields = fields.concat(result);
			var _g4 = 0;
			while(_g4 < fields.length) {
				var field = fields[_g4];
				++_g4;
				if(field.access != null) {
					var _g5 = [];
					var _g12 = 0;
					var _g21 = field.access;
					while(_g12 < _g21.length) {
						var v1 = _g21[_g12];
						++_g12;
						if(v1._hx_index == 7) {
							_g5.push(v1);
						}
					}
					field.access = _g5;
				}
			}
			tool_HaxeTools.resolveNameCollisions(fields);
			return haxe_macro_ComplexType.TAnonymous(fields);
		}
	}
	,functionFieldFromCallSignatures: function(fieldName,callSignatures,accessContext,enclosingDeclaration) {
		var field = this.functionFieldFromSignatures(fieldName,callSignatures,accessContext,enclosingDeclaration);
		tool_HaxeTools.setMeta(field,":selfCall");
		return field;
	}
	,functionFieldFromSignatures: function(fieldName,signatures,accessContext,enclosingDeclaration) {
		var _gthis = this;
		var baseSignature = signatures[0];
		var overloadSignatures = signatures.slice(1);
		var result = new Array(overloadSignatures.length);
		var _g = 0;
		var _g1 = overloadSignatures.length;
		while(_g < _g1) {
			var i = _g++;
			var fun = _gthis.functionFromSignature(overloadSignatures[i],accessContext,enclosingDeclaration);
			fun.expr = { expr : haxe_macro_ExprDef.EBlock([]), pos : { file : "src/ConverterContext.hx", min : 47203, max : 47205}};
			result[i] = { name : ":overload", params : [{ expr : haxe_macro_ExprDef.EFunction(haxe_macro_FunctionKind.FAnonymous,fun), pos : null}], pos : null};
		}
		var overloadMetas = result;
		var _this = baseSignature.getDocumentationComment(this.tc);
		var result1 = new Array(_this.length);
		var _g2 = 0;
		var _g11 = _this.length;
		while(_g2 < _g11) {
			var i1 = _g2++;
			result1[i1] = _this[i1].text;
		}
		var baseDoc = result1.join("\n");
		return { name : fieldName, meta : overloadMetas, kind : haxe_macro_FieldType.FFun(this.functionFromSignature(baseSignature,accessContext,enclosingDeclaration)), doc : baseDoc, pos : null};
	}
	,newFieldFromSignatures: function(signatures,accessContext,enclosingDeclaration) {
		var field = this.functionFieldFromSignatures("new",signatures,accessContext,enclosingDeclaration);
		var _g = field.kind;
		if(_g._hx_index == 1) {
			var fun = _g.f;
			fun.ret = null;
		}
		return field;
	}
	,complexTypeFromCallSignature: function(callSignature,accessContext,enclosingDeclaration) {
		var fun = this.functionFromSignature(callSignature,accessContext,enclosingDeclaration);
		if(fun.params != null && fun.params.length > 0) {
			fun = tool_ComplexTypeTools.mapFunction(fun,function(t) {
				if(t._hx_index == 0) {
					var _g = t.p;
					var _g4 = _g.sub;
					var _g3 = _g.params;
					if(_g.pack.length == 0) {
						var name = _g.name;
						if(Lambda.exists(fun.params,function(tp) {
							return tp.name == name;
						})) {
							return haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []});
						} else {
							return t;
						}
					} else {
						return t;
					}
				} else {
					return t;
				}
			});
			fun.params = null;
		}
		var _this = fun.args;
		var result = new Array(_this.length);
		var _g1 = 0;
		var _g11 = _this.length;
		while(_g1 < _g11) {
			var i = _g1++;
			var arg = _this[i];
			result[i] = haxe_macro_ComplexType.TNamed(arg.name,arg.type != null ? arg.type : haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}));
		}
		var hxArgs = result;
		var hxReturnType = fun.ret != null ? fun.ret : haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		var functionSignatures = [];
		var hxNonOptionalArgs = [];
		var _g2 = 0;
		var _g12 = fun.args.length;
		while(_g2 < _g12) {
			var i1 = _g2++;
			var arg1 = fun.args[i1];
			if(arg1.opt == true) {
				break;
			}
			hxNonOptionalArgs.push(hxArgs[i1]);
		}
		functionSignatures.push(haxe_macro_ComplexType.TFunction(hxNonOptionalArgs,hxReturnType));
		var _g21 = 0;
		var _g31 = fun.args.length;
		while(_g21 < _g31) {
			var i2 = _g21++;
			var arg2 = fun.args[i2];
			if(arg2.opt == true) {
				functionSignatures.push(haxe_macro_ComplexType.TFunction(hxArgs.slice(0,i2 + 1),hxReturnType));
			}
		}
		return SupportTypes.getUnionType(this,functionSignatures);
	}
	,complexTypeFromTypeReference: function(typeReference,accessContext,preferInterfaceStructure,enclosingDeclaration) {
		var _gthis = this;
		if((typeReference.objectFlags & ts.ObjectFlags.ClassOrInterface) != 0) {
			return this.complexTypeFromGenericType(typeReference,accessContext,preferInterfaceStructure,enclosingDeclaration);
		} else if((typeReference.target.objectFlags & ts.ObjectFlags.Tuple) != 0) {
			return this.complexTypeFromTupleTypeReference(typeReference,accessContext,enclosingDeclaration);
		} else {
			if(typeReference.target == typeReference) {
				Log.error("Internal error: recursive type reference");
				return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
			}
			var hxTarget = this.complexTypeFromTsType(typeReference.target,accessContext,enclosingDeclaration,null,preferInterfaceStructure);
			var hxTypeArguments;
			if(typeReference.typeArguments != null) {
				var _this = typeReference.typeArguments;
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = haxe_macro_TypeParam.TPType(_gthis.complexTypeFromTsType(_this[i],accessContext,enclosingDeclaration));
				}
				hxTypeArguments = result;
			} else {
				hxTypeArguments = [];
			}
			if(hxTarget._hx_index == 0) {
				var p = hxTarget.p;
				var argumentCount = hxTypeArguments.length;
				var paramCount = p.params != null ? p.params.length : 0;
				if(paramCount != argumentCount) {
					Log.warn("TypeReference has <b>" + argumentCount + "</> arguments but target has <b>" + paramCount + "</> parameters",null,null,typeReference);
				}
				p.params = hxTypeArguments;
			} else {
				Log.error("Internal error: Expected TPath from TypeReference",null,null,typeReference);
			}
			return hxTarget;
		}
	}
	,complexTypeFromTupleTypeReference: function(tupleTypeReference,accessContext,enclosingDeclaration) {
		var _gthis = this;
		var _this = tupleTypeReference.typeArguments;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.complexTypeFromTsType(_this[i],accessContext,enclosingDeclaration);
		}
		var hxElementTypes = result;
		return SupportTypes.getTupleType(this,hxElementTypes);
	}
	,complexTypeFromGenericType: function(genericType,accessContext,preferInterfaceStructure,enclosingDeclaration) {
		if((genericType.objectFlags & ts.ObjectFlags.Tuple) != 0) {
			return this.complexTypeFromTupleType(genericType,accessContext,enclosingDeclaration);
		} else {
			return this.complexTypeFromInterfaceType(genericType,accessContext,preferInterfaceStructure,enclosingDeclaration);
		}
	}
	,complexTypeFromTupleType: function(tupleType,accessContext,enclosingDeclaration) {
		Log.warn("Todo: TupleType",null,null,tupleType);
		debugger;
		return haxe_macro_ComplexType.TPath({ pack : ["std"], name : "Array", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
	}
	,complexTypeFromInterfaceType: function(classOrInterfaceType,accessContext,preferInterfaceStructure,enclosingDeclaration) {
		var _gthis = this;
		if(classOrInterfaceType.symbol != null) {
			var hxTypePath = this.getReferencedHaxeTypePath(classOrInterfaceType.symbol,accessContext,preferInterfaceStructure);
			var tmp;
			if(classOrInterfaceType.typeParameters != null) {
				var _this = classOrInterfaceType.typeParameters;
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = haxe_macro_TypeParam.TPType(_gthis.complexTypeFromTypeParameter(_this[i],accessContext,enclosingDeclaration));
				}
				tmp = result;
			} else {
				tmp = null;
			}
			hxTypePath.params = tmp;
			return haxe_macro_ComplexType.TPath(hxTypePath);
		} else {
			Log.error("Internal error: no symbol for ClassOrInterface type",null,null,classOrInterfaceType);
			debugger;
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		}
	}
	,complexTypeBaseOfEnumSymbol: function(symbol) {
		var hxEnumTypeName = null;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.tc.getExportsOfModule(symbol);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if((v.flags & ts.SymbolFlags.EnumMember) != 0) {
				_g.push(v);
			}
		}
		var enumMembers = _g;
		var _g3 = 0;
		while(_g3 < enumMembers.length) {
			var member = enumMembers[_g3];
			++_g3;
			var enumMemberNode = member.valueDeclaration;
			var runtimeValue = this.tc.getConstantValue(enumMemberNode);
			var hxMemberTypeName;
			switch(typeof(runtimeValue)) {
			case "number":
				hxMemberTypeName = Math.floor(runtimeValue) == runtimeValue ? "Int" : "Float";
				break;
			case "string":
				hxMemberTypeName = "String";
				break;
			case "undefined":
				hxMemberTypeName = "Int";
				break;
			default:
				hxMemberTypeName = "Any";
			}
			if(hxEnumTypeName != hxMemberTypeName) {
				if(hxEnumTypeName == null) {
					hxEnumTypeName = hxMemberTypeName;
				} else {
					switch(hxEnumTypeName) {
					case "Float":
						hxEnumTypeName = hxMemberTypeName == "Int" ? "Float" : "Any";
						break;
					case "Int":
						hxEnumTypeName = hxMemberTypeName == "Float" ? "Float" : "Any";
						break;
					default:
						hxEnumTypeName = "Any";
					}
				}
			}
		}
		if(hxEnumTypeName != null) {
			return haxe_macro_ComplexType.TPath({ pack : [], name : hxEnumTypeName});
		} else {
			return haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []});
		}
	}
	,complexTypeFromTypeNode: function(node,accessContext,enclosingDeclaration) {
		var type = this.tc.getTypeFromTypeNode(node);
		if(type.intrinsicName == "error") {
			debugger;
			Log.error("Internal error: Error getting type from type node",node);
		}
		return this.complexTypeFromTsType(type,accessContext,enclosingDeclaration);
	}
	,getTsTypeOfField: function(symbol) {
		if(symbol.valueDeclaration == null) {
			if(Reflect.field(symbol,"type") != null) {
				return Reflect.field(symbol,"type");
			} else {
				return this.tc.getDeclaredTypeOfSymbol(symbol);
			}
		} else {
			return this.tc.getTypeOfSymbolAtLocation(symbol,symbol.valueDeclaration);
		}
	}
	,fieldFromSymbol: function(nativeFieldName,symbol,accessContext,enclosingDeclaration) {
		var pos = tool_TsSymbolTools.getPosition(symbol);
		var meta = [];
		var safeName = tool_HaxeTools.toSafeIdent(nativeFieldName);
		var nameChanged = safeName != nativeFieldName;
		if(nameChanged) {
			meta.push({ name : ":native", pos : pos, params : [tool_HaxeTools.toStringExpr(nativeFieldName,pos)]});
		}
		var isOptional = (symbol.flags & ts.SymbolFlags.Optional) != 0;
		if(isOptional) {
			meta.push({ name : ":optional", pos : pos});
		}
		var baseDeclaration;
		if(symbol.valueDeclaration != null) {
			baseDeclaration = symbol.valueDeclaration;
		} else {
			Log.warn("Missing valueDeclaration for field symbol",null,symbol);
			baseDeclaration = null;
		}
		var hxAccessModifiers = baseDeclaration != null && baseDeclaration.modifiers != null ? this.accessFromModifiers(baseDeclaration.modifiers,symbol) : [];
		var userDoc = this.getDoc(symbol);
		var docParts = userDoc != "" ? [userDoc] : [];
		var tsType = this.getTsTypeOfField(symbol);
		var onError = function(message) {
			Log.error("fieldFromSymbol(): " + message,null,symbol);
			var onError1 = "@DTS2HX-ERROR: " + Console.stripFormatting(message);
			docParts.push(onError1);
		};
		var kind;
		if((symbol.flags & ts.SymbolFlags.Prototype) != 0) {
			Log.error("Internal error: Prototype symbol should not be converted to a field",null,symbol);
			debugger;
			kind = haxe_macro_FieldType.FVar(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}),null);
		} else if((symbol.flags & (ts.SymbolFlags.PropertyOrAccessor | ts.SymbolFlags.Variable)) != 0) {
			if(baseDeclaration != null) {
				switch(baseDeclaration.kind) {
				case ts.SyntaxKind.PropertyDeclaration:case ts.SyntaxKind.PropertySignature:case ts.SyntaxKind.VariableDeclaration:
					break;
				case ts.SyntaxKind.GetAccessor:case ts.SyntaxKind.SetAccessor:
					break;
				default:
					onError("Unhandled declaration kind <b>" + tool_TsSyntaxTools.getSyntaxKindName(baseDeclaration.kind) + "</>");
				}
			}
			var hxType = this.complexTypeFromTsType(tsType,accessContext,enclosingDeclaration);
			if(isOptional) {
				hxType = tool_HaxeTools.unwrapNull(hxType);
			}
			if((symbol.flags & ts.SymbolFlags.GetAccessor) != 0 && (symbol.flags & ts.SymbolFlags.SetAccessor) == 0) {
				if(!Lambda.has(hxAccessModifiers,haxe_macro_Access.AFinal)) {
					hxAccessModifiers.push(haxe_macro_Access.AFinal);
				}
			}
			kind = haxe_macro_FieldType.FVar(hxType,null);
		} else if((symbol.flags & (ts.SymbolFlags.Method | ts.SymbolFlags.Function)) != 0) {
			if(baseDeclaration != null) {
				switch(baseDeclaration.kind) {
				case ts.SyntaxKind.FunctionDeclaration:case ts.SyntaxKind.MethodDeclaration:case ts.SyntaxKind.MethodSignature:
					break;
				default:
					onError("Unhandled declaration kind <b>" + tool_TsSyntaxTools.getSyntaxKindName(baseDeclaration.kind) + "</>");
				}
			}
			var signatures = this.tc.getSignaturesOfType(this.tc.getNonNullableType(tsType),ts.SignatureKind.Call);
			if(signatures.length > 0) {
				var functionField = this.functionFieldFromSignatures(safeName,signatures,accessContext,enclosingDeclaration);
				if(functionField.meta != null) {
					meta = meta.concat(functionField.meta);
				}
				kind = functionField.kind;
			} else {
				onError("Internal error: failed to get function signatures from type (type is probably wrapped in another)");
				kind = haxe_macro_FieldType.FFun({ args : [], ret : haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []}), params : [], expr : null});
			}
		} else if((symbol.flags & ts.SymbolFlags.EnumMember) != 0) {
			var parent = tool_TsSymbolTools.getSymbolParent(symbol);
			var isConstEnum;
			if(parent != null) {
				isConstEnum = (parent.flags & ts.SymbolFlags.ConstEnum) != 0;
			} else {
				Log.error("EnumMember did not have a parent",null,symbol);
				isConstEnum = true;
			}
			kind = haxe_macro_FieldType.FVar(null,isConstEnum ? tool_HaxeTools.primitiveValueToExpr(this.tc.getConstantValue(symbol.valueDeclaration)) : null);
		} else {
			onError("Unhandled symbol flags");
			var type = this.tc.getTypeOfSymbolAtLocation(symbol,symbol.valueDeclaration);
			debugger;
			kind = haxe_macro_FieldType.FVar(this.complexTypeFromTsType(type,accessContext,enclosingDeclaration),null);
		}
		var field = { name : safeName, meta : meta, pos : pos, kind : kind, doc : docParts.join("\n\n"), access : hxAccessModifiers};
		var hasPrivateAccess = tool_HaxeTools.hasAccess(field,haxe_macro_Access.APrivate);
		if(hasPrivateAccess) {
			tool_HaxeTools.setMeta(field,":noCompletion");
		}
		tool_HaxeTools.disableAccess(field,haxe_macro_Access.APrivate);
		return field;
	}
	,functionFromSignature: function(signature,accessContext,enclosingDeclaration) {
		var _gthis = this;
		var hxTypeParams;
		if(signature.typeParameters != null) {
			var _this = signature.typeParameters;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _gthis.typeParamDeclFromTsTypeParameter(_this[i],accessContext,enclosingDeclaration);
			}
			hxTypeParams = result;
		} else {
			hxTypeParams = [];
		}
		var hxParameters;
		if(signature.parameters != null) {
			var _this1 = TsInternal.getExpandedParameters(this.tc,signature);
			var result1 = new Array(_this1.length);
			var _g2 = 0;
			var _g11 = _this1.length;
			while(_g2 < _g11) {
				var i1 = _g2++;
				var s = _this1[i1];
				var parameterDeclaration = s.valueDeclaration;
				var isOptional = parameterDeclaration != null && _gthis.tc.isOptionalParameter(parameterDeclaration);
				var isRest = parameterDeclaration != null && parameterDeclaration.dotDotDotToken != null;
				var tsType = parameterDeclaration != null ? _gthis.tc.getTypeOfSymbolAtLocation(s,parameterDeclaration) : s.type;
				var hxType = _gthis.complexTypeFromTsType(tsType,accessContext,parameterDeclaration);
				if(isRest) {
					if(hxType._hx_index == 0) {
						var _g3 = hxType.p;
						var _g4 = _g3.sub;
						var _g31 = _g3.params;
						var _g21 = _g3.pack;
						if(_g3.name == "Array") {
							if(_g31 == null) {
								Log.warn("Unsupported rest type",null,s);
								hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
							} else if(_g31.length == 1) {
								var _g5 = _g31[0];
								if(_g5._hx_index == 0) {
									var param = _g5.t;
									hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(param)]});
								} else {
									Log.warn("Unsupported rest type",null,s);
									hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
								}
							} else {
								Log.warn("Unsupported rest type",null,s);
								hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
							}
						} else {
							Log.warn("Unsupported rest type",null,s);
							hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
						}
					} else {
						Log.warn("Unsupported rest type",null,s);
						hxType = haxe_macro_ComplexType.TPath({ pack : ["haxe","extern"], name : "Rest", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
					}
				}
				if(isOptional) {
					hxType = tool_HaxeTools.unwrapNull(hxType);
				}
				var value = parameterDeclaration != null ? tool_HaxeTools.primitiveValueToExpr(_gthis.tc.getConstantValue(parameterDeclaration)) : null;
				result1[i1] = { name : tool_HaxeTools.toSafeIdent(s.name), type : hxType, opt : isOptional, value : value};
			}
			hxParameters = result1;
		} else {
			hxParameters = [];
		}
		var hxRet = this.complexTypeFromTsType(this.tc.getReturnTypeOfSignature(signature),accessContext,signature.declaration);
		return { args : hxParameters, ret : hxRet, params : hxTypeParams, expr : null};
	}
	,typeParamDeclFromTypeDeclarationSymbol: function(symbol,accessContext,enclosingDeclaration) {
		var tsTypeParameterDeclarations = [];
		var _g = [];
		var _g1 = 0;
		var _g2 = symbol.declarations;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			var tmp;
			switch(v.kind) {
			case ts.SyntaxKind.ClassDeclaration:case ts.SyntaxKind.InterfaceDeclaration:case ts.SyntaxKind.ModuleDeclaration:case ts.SyntaxKind.SourceFile:case ts.SyntaxKind.TypeAliasDeclaration:case ts.SyntaxKind.VariableDeclaration:
				tmp = true;
				break;
			default:
				tmp = false;
			}
			if(tmp) {
				_g.push(v);
			}
		}
		var typeDeclarations = _g;
		if(typeDeclarations.length == 0) {
			Log.warn("Internal error: typeParamDeclFromTypeDeclarationSymbol() expected symbol to have at least one recognized type declaration",null,symbol);
			var _this = symbol.declarations;
			var result = new Array(_this.length);
			var _g3 = 0;
			var _g11 = _this.length;
			while(_g3 < _g11) {
				var i = _g3++;
				result[i] = tool_TsSyntaxTools.getSyntaxKindName(_this[i].kind);
			}
			Log.warn("\tdeclarations: <b>" + Std.string(result) + "</>");
		}
		var _g4 = 0;
		while(_g4 < typeDeclarations.length) {
			var declaration = typeDeclarations[_g4];
			++_g4;
			var declarationTypeParameters = ts.getEffectiveTypeParameterDeclarations(declaration);
			if(tsTypeParameterDeclarations.length > 0 && declarationTypeParameters.length > 0) {
				if(tsTypeParameterDeclarations.length != declarationTypeParameters.length) {
					Log.warn("Symbol declarations have varying number of type-parameters; this is not expected",null,symbol);
				}
			}
			if(declarationTypeParameters.length > 0 && declarationTypeParameters.length > tsTypeParameterDeclarations.length) {
				tsTypeParameterDeclarations = declarationTypeParameters;
			}
		}
		var _g12 = [];
		var _g21 = 0;
		while(_g21 < tsTypeParameterDeclarations.length) {
			var t = tsTypeParameterDeclarations[_g21];
			++_g21;
			_g12.push({ name : tool_TsSyntaxTools.typeParameterDeclarationName(t), constraints : this.enableTypeParameterConstraints && t.constraint != null ? [this.complexTypeFromTypeNode(t.constraint,accessContext,enclosingDeclaration)] : null});
		}
		return _g12;
	}
	,typeParamDeclFromTsTypeParameter: function(typeParameter,accessContext,enclosingDeclaration) {
		var typeParamNode = Lambda.find(typeParameter.symbol.declarations,function(d) {
			return d.kind == ts.SyntaxKind.TypeParameter;
		});
		var hxConstraint = typeParamNode != null && typeParamNode.constraint != null ? this.complexTypeFromTypeNode(typeParamNode.constraint,accessContext,enclosingDeclaration) : null;
		return { name : tool_HaxeTools.toSafeTypeName(typeParameter.symbol.name), constraints : this.enableTypeParameterConstraints && hxConstraint != null ? [hxConstraint] : null};
	}
	,accessFromModifiers: function(modifiers,logSymbol) {
		var access = [];
		var _g = 0;
		var _g1 = modifiers;
		while(_g < _g1.length) {
			var modifier = _g1[_g];
			++_g;
			switch(modifier.kind) {
			case ts.SyntaxKind.AbstractKeyword:
				Log.warn("`abstract` modifier not handled",null,logSymbol);
				break;
			case ts.SyntaxKind.AsyncKeyword:
				Log.warn("`async` modifier not handled",null,logSymbol);
				break;
			case ts.SyntaxKind.ConstKeyword:
				access.push(haxe_macro_Access.AFinal);
				break;
			case ts.SyntaxKind.DeclareKeyword:
				break;
			case ts.SyntaxKind.DefaultKeyword:
				break;
			case ts.SyntaxKind.ExportKeyword:
				break;
			case ts.SyntaxKind.PrivateKeyword:
				access.push(haxe_macro_Access.APrivate);
				break;
			case ts.SyntaxKind.ProtectedKeyword:
				access.push(haxe_macro_Access.APrivate);
				break;
			case ts.SyntaxKind.PublicKeyword:
				access.push(haxe_macro_Access.APublic);
				break;
			case ts.SyntaxKind.ReadonlyKeyword:
				access.push(haxe_macro_Access.AFinal);
				break;
			case ts.SyntaxKind.StaticKeyword:
				access.push(haxe_macro_Access.AStatic);
				break;
			default:
				Log.warn("Unhandled modifier kind <b>" + tool_TsSyntaxTools.getSyntaxKindName(modifier.kind) + "</b>");
			}
		}
		return access;
	}
	,isHxAny: function(t) {
		if(t._hx_index == 0) {
			var _g = t.p;
			var _g4 = _g.sub;
			var _g3 = _g.params;
			var _g2 = _g.pack;
			switch(_g.name) {
			case "Any":
				switch(_g2.length) {
				case 0:
					return true;
				case 1:
					if(_g2[0] == "std") {
						return true;
					} else {
						return false;
					}
					break;
				default:
					return false;
				}
				break;
			case "Dynamic":
				switch(_g2.length) {
				case 0:
					return true;
				case 1:
					if(_g2[0] == "std") {
						return true;
					} else {
						return false;
					}
					break;
				default:
					return false;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,normalizeModuleName: function(moduleName) {
		if(tool_TsProgramTools.isDirectPathReferenceModule(moduleName)) {
			moduleName = TsInternal.convertToRelativePath(moduleName,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName)));
		}
		StringTools.replace(moduleName,"\\","/");
		var moduleNameParts = moduleName.split("/");
		if(moduleNameParts[0] == "@types" && moduleNameParts.length > 1) {
			moduleNameParts.shift();
		}
		return moduleNameParts.join("/");
	}
	,cwdRelativeFilePath: function(path) {
		return TsInternal.convertToRelativePath(path,this.host.getCurrentDirectory(),($_=this.host,$bind($_,$_.getCanonicalFileName)));
	}
};
var HaxeTypePathMap = function(entryPointModuleId,program,symbolAccessMap) {
	this.entryPointModuleId = entryPointModuleId;
	this.program = program;
	this.symbolAccessMap = symbolAccessMap;
	this.tc = program.getTypeChecker();
	this.symbolTypePathMap = this.buildHaxeTypePathMap();
};
HaxeTypePathMap.__name__ = true;
HaxeTypePathMap.prototype = {
	getTypePath: function(symbol,accessContext,preferInterfaceStructure) {
		if((symbol.flags & ts.SymbolFlags.Alias) != 0) {
			symbol = this.tc.getAliasedSymbol(symbol);
		}
		var this1 = this.symbolTypePathMap;
		var key = tool_TsSymbolTools.getId(symbol);
		var modules = this1.h[key];
		if(modules != null) {
			var _g = [];
			var _g1 = 0;
			var _g2 = modules;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v.isInterfaceStructure == preferInterfaceStructure) {
					_g.push(v);
				}
			}
			var interfaceStructureFilteredModules = _g;
			if(interfaceStructureFilteredModules.length > 0) {
				modules = interfaceStructureFilteredModules;
			}
			var matchingModule = Lambda.find(modules,function(m) {
				return m.access._hx_index == accessContext._hx_index;
			});
			if(matchingModule == null) {
				matchingModule = Lambda.find(modules,function(m1) {
					return m1.access._hx_index != 3;
				});
			}
			if(matchingModule == null) {
				matchingModule = modules[0];
			}
			if(matchingModule != null) {
				return matchingModule;
			} else {
				Log.warn("Internal error: Could not find a type path for symbol with the supplied access context <b>" + tool_SymbolAccessTools.toString(accessContext) + "</>",null,symbol);
			}
		} else {
			Log.warn("Internal error: No type paths were generated for this symbol",null,symbol);
		}
		if(!ConverterContext.isHaxeModuleSource(this.tc,symbol)) {
			Log.warn("Internal error: unexpected symbol passed into `getTypePath()`",null,symbol);
		}
		debugger;
		return this.generateTypePath(symbol,accessContext,preferInterfaceStructure);
	}
	,getGlobalModuleTypePath: function(symbol,access) {
		var typePath = this.generateTypePath(symbol,access,false);
		return { name : "Global", pack : typePath.pack};
	}
	,buildHaxeTypePathMap: function() {
		var _gthis = this;
		var packageMap = new haxe_ds_StringMap();
		var getModules = function(pack) {
			var packageKey = pack.join("/");
			var modules = __map_reserved[packageKey] != null ? packageMap.getReserved(packageKey) : packageMap.h[packageKey];
			if(modules == null) {
				modules = [];
				if(__map_reserved[packageKey] != null) {
					packageMap.setReserved(packageKey,modules);
				} else {
					packageMap.h[packageKey] = modules;
				}
			}
			return modules;
		};
		var _g = 0;
		var _g1 = tool_TsProgramTools.getTopLevelDeclarationSymbols(this.program);
		while(_g < _g1.length) {
			var topLevelSymbol = _g1[_g];
			++_g;
			tool_TsSymbolTools.walkDeclarationSymbols(this.tc,topLevelSymbol,function(symbol,_) {
				var _g2 = 0;
				var _g11 = _gthis.symbolAccessMap.getAccess(symbol);
				while(_g2 < _g11.length) {
					var access = _g11[_g2];
					++_g2;
					if(ConverterContext.isHaxeModuleSource(_gthis.tc,symbol)) {
						var typePath = _gthis.generateTypePath(symbol,access,false);
						var modules1 = getModules(typePath.pack);
						if(Lambda.find(modules1,function(m) {
							if(m.symbol == symbol) {
								return m.isInterfaceStructure == false;
							} else {
								return false;
							}
						}) == null) {
							modules1.push({ name : typePath.name, pack : typePath.pack, isExistingStdLibType : typePath.isExistingStdLibType, symbol : symbol, access : access, renameable : true, isInterfaceStructure : false});
						}
						if(ConverterContext.requiresAdditionalStructureType(_gthis.tc,symbol)) {
							var typePath1 = _gthis.generateTypePath(symbol,access,true);
							var modules2 = getModules(typePath1.pack);
							if(Lambda.find(modules2,function(m1) {
								if(m1.symbol == symbol) {
									return m1.isInterfaceStructure == true;
								} else {
									return false;
								}
							}) == null) {
								modules2.push({ name : typePath1.name, pack : typePath1.pack, isExistingStdLibType : typePath1.isExistingStdLibType, symbol : symbol, access : access, renameable : true, isInterfaceStructure : true});
							}
						}
					}
					if(ConverterContext.isGlobalField(_gthis.tc,symbol,access)) {
						var typePath2 = _gthis.generateTypePath(symbol,access,false);
						var modules3 = getModules(typePath2.pack);
						if(Lambda.find(modules3,function(m2) {
							if(m2.name == "Global") {
								return m2.renameable == false;
							} else {
								return false;
							}
						}) == null) {
							modules3.push({ name : "Global", pack : typePath2.pack, isExistingStdLibType : false, symbol : null, access : SymbolAccess.Global([]), renameable : false, isInterfaceStructure : false});
						}
					}
				}
				return;
			});
		}
		var _g21 = new haxe_iterators_MapKeyValueIterator(packageMap);
		while(_g21.hasNext()) {
			var _g3 = _g21.next();
			var _1 = _g3.key;
			var modules4 = _g3.value;
			while(true) {
				var degenerateNameMap = new haxe_ds_StringMap();
				var _g4 = 0;
				while(_g4 < modules4.length) {
					var $module = modules4[_g4];
					++_g4;
					var lowercaseName = $module.name.toLowerCase();
					var matches = __map_reserved[lowercaseName] != null ? degenerateNameMap.getReserved(lowercaseName) : degenerateNameMap.h[lowercaseName];
					if(matches == null) {
						matches = [];
						if(__map_reserved[lowercaseName] != null) {
							degenerateNameMap.setReserved(lowercaseName,matches);
						} else {
							degenerateNameMap.h[lowercaseName] = matches;
						}
					}
					matches.push($module);
				}
				var hasNameOverlap = false;
				var _g5 = new haxe_iterators_MapKeyValueIterator(degenerateNameMap);
				while(_g5.hasNext()) {
					var _g6 = _g5.next();
					var degenerateName = _g6.key;
					var matches1 = _g6.value;
					if(matches1.length > 1) {
						hasNameOverlap = true;
						haxe_ds_ArraySort.sort(matches1,function(a,b) {
							var renameabilityA = a.renameable ? 1 : 0 | (!a.isExistingStdLibType ? 1 : 0) << 5 | (a.access._hx_index == 3 ? 1 : 0) << 4 | ((a.symbol.flags & ts.SymbolFlags.ValueModule) == 0 ? 1 : 0) << 3 | ((a.symbol.flags & ts.SymbolFlags.Class) == 0 ? 1 : 0) << 2 | ((a.symbol.flags & ts.SymbolFlags.Enum) == 0 ? 1 : 0) << 1 | ((a.symbol.flags & ts.SymbolFlags.TypeAlias) == 0 ? 1 : 0);
							var renameabilityB = b.renameable ? 1 : 0 | (!b.isExistingStdLibType ? 1 : 0) << 5 | (b.access._hx_index == 3 ? 1 : 0) << 4 | ((b.symbol.flags & ts.SymbolFlags.ValueModule) == 0 ? 1 : 0) << 3 | ((b.symbol.flags & ts.SymbolFlags.Class) == 0 ? 1 : 0) << 2 | ((b.symbol.flags & ts.SymbolFlags.Enum) == 0 ? 1 : 0) << 1 | ((b.symbol.flags & ts.SymbolFlags.TypeAlias) == 0 ? 1 : 0);
							if(renameabilityA > renameabilityB) {
								return -1;
							} else if(renameabilityA < renameabilityB) {
								return 1;
							} else if(a.symbol.name > b.symbol.name) {
								return -1;
							} else {
								return 1;
							}
						});
						var moduleToRename = matches1[0];
						moduleToRename.name += "_";
						var tmp = "Resolved name overlap for <b>" + matches1[0].pack.concat([degenerateName]).join("/") + ".hx</>: ";
						var result = new Array(matches1.length);
						var _g7 = 0;
						var _g12 = matches1.length;
						while(_g7 < _g12) {
							var i = _g7++;
							result[i] = matches1[i].name;
						}
						Log.log(tmp + result.join(", "));
					}
				}
				if(!hasNameOverlap) {
					break;
				}
			}
		}
		var typePathMap = new haxe_ds_IntMap();
		var _g22 = new haxe_iterators_MapKeyValueIterator(packageMap);
		while(_g22.hasNext()) {
			var _g31 = _g22.next();
			var _2 = _g31.key;
			var modules5 = _g31.value;
			var _g41 = 0;
			while(_g41 < modules5.length) {
				var module1 = modules5[_g41];
				++_g41;
				if(module1.symbol == null) {
					continue;
				}
				var key = tool_TsSymbolTools.getId(module1.symbol);
				var array = typePathMap.h[key];
				if(array == null) {
					array = [];
					var key1 = tool_TsSymbolTools.getId(module1.symbol);
					typePathMap.h[key1] = array;
				}
				array.push(module1);
			}
		}
		return typePathMap;
	}
	,generateTypePath: function(symbol,access,asInterfaceStructure) {
		var isBuiltIn = false;
		var defaultLibOnlyDeclarations = true;
		var _g = 0;
		var _g1 = tool_TsSymbolTools.getDeclarationsArray(symbol);
		while(_g < _g1.length) {
			var declaration = _g1[_g];
			++_g;
			var sourceFile = declaration.getSourceFile();
			if(sourceFile.hasNoDefaultLib) {
				isBuiltIn = true;
			} else {
				defaultLibOnlyDeclarations = false;
			}
		}
		if(defaultLibOnlyDeclarations && !asInterfaceStructure) {
			var _g2 = new haxe_ds_StringMap();
			var value = { name : "Array", pack : []};
			if(__map_reserved["Array"] != null) {
				_g2.setReserved("Array",value);
			} else {
				_g2.h["Array"] = value;
			}
			var value1 = { name : "String", pack : []};
			if(__map_reserved["String"] != null) {
				_g2.setReserved("String",value1);
			} else {
				_g2.h["String"] = value1;
			}
			var value2 = { name : "Symbol", pack : ["js","lib"]};
			if(__map_reserved["Symbol"] != null) {
				_g2.setReserved("Symbol",value2);
			} else {
				_g2.h["Symbol"] = value2;
			}
			var specialTypeMap = _g2;
			if(access._hx_index == 2) {
				var _g3 = access.symbolChain;
				if(_g3.length == 1) {
					var _g4 = _g3[0];
					var _g12 = _g4.valueDeclaration;
					var _g10 = _g4.members;
					var _g9 = _g4.globalExports;
					var _g8 = _g4.flags;
					var _g7 = _g4.exports;
					var _g6 = _g4.escapedName;
					var _g5 = _g4.declarations;
					var name = _g4.name;
					if(__map_reserved[name] != null ? specialTypeMap.existsReserved(name) : specialTypeMap.h.hasOwnProperty(name)) {
						var tp = __map_reserved[name] != null ? specialTypeMap.getReserved(name) : specialTypeMap.h[name];
						return { name : tp.name, pack : tp.pack, isExistingStdLibType : true};
					}
				}
			}
		}
		var hasDeclarationInLib = function(symbol1,filename) {
			var _g21 = 0;
			var _g31 = tool_TsSymbolTools.getDeclarationsArray(symbol1);
			while(_g21 < _g31.length) {
				var declaration1 = _g31[_g21];
				++_g21;
				var sourceFile1 = declaration1.getSourceFile();
				if(sourceFile1.hasNoDefaultLib && haxe_io_Path.withoutDirectory(sourceFile1.fileName).toLowerCase() == filename) {
					return true;
				}
			}
			return false;
		};
		var pack = isBuiltIn ? hasDeclarationInLib(symbol,"lib.dom.d.ts") ? ["ts","html"] : ["ts","lib"] : [];
		var identifierChain = tool_SymbolAccessTools.getIdentifierChain(access);
		switch(access._hx_index) {
		case 0:
			var _g41 = access.symbolChain;
			var _g32 = access.moduleSymbol;
			var modulePath = access.modulePath;
			var entryPointPack = this.splitModulePath(this.entryPointModuleId);
			var modulePack = this.splitModulePath(modulePath);
			if(tool_HaxeTools.toSafePackageName(entryPointPack[entryPointPack.length - 1]) == tool_HaxeTools.toSafePackageName(modulePack[0])) {
				modulePack.shift();
			}
			pack = pack.concat(entryPointPack).concat(modulePack).concat(identifierChain);
			pack.pop();
			break;
		case 1:
			var _g81 = access.symbolChain;
			var _g71 = access.sourceFileSymbol;
			var moduleName = access.moduleName;
			pack = pack.concat(this.splitModulePath(moduleName)).concat(identifierChain);
			pack.pop();
			break;
		case 2:
			var _g51 = access.symbolChain;
			pack = pack.concat(isBuiltIn ? [] : ["global"]).concat(identifierChain);
			pack.pop();
			break;
		case 3:
			var entryPointPack1 = this.splitModulePath(this.entryPointModuleId);
			var pack1 = pack.concat(entryPointPack1);
			var _g11 = [];
			var _g13 = 0;
			var _g22 = tool_TsSymbolTools.getSymbolParents(symbol);
			while(_g13 < _g22.length) {
				var v = _g22[_g13];
				++_g13;
				if(!new EReg("^__\\w","").match(v.name)) {
					_g11.push(v);
				}
			}
			var _g14 = [];
			var _g15 = 0;
			var _g23 = _g11;
			while(_g15 < _g23.length) {
				var v1 = _g23[_g15];
				++_g15;
				if(!tool_TsSymbolTools.isSourceFileSymbol(v1)) {
					_g14.push(v1);
				}
			}
			var _this = _g14;
			var result = new Array(_this.length);
			var _g16 = 0;
			var _g17 = _this.length;
			while(_g16 < _g17) {
				var i = _g16++;
				result[i] = _this[i].name;
			}
			pack = pack1.concat(result);
			break;
		}
		var result1 = new Array(pack.length);
		var _g18 = 0;
		var _g19 = pack.length;
		while(_g18 < _g19) {
			var i1 = _g18++;
			result1[i1] = tool_HaxeTools.toSafePackageName(pack[i1]);
		}
		pack = result1;
		var typeIdentifier;
		switch(access._hx_index) {
		case 0:
			var _g101 = access.moduleSymbol;
			var symbolChain = access.symbolChain;
			var path = access.modulePath;
			var lastSymbol = symbolChain[symbolChain.length - 1];
			typeIdentifier = lastSymbol != null ? tool_TsSymbolTools.isInternalSymbolName(lastSymbol.escapedName) ? symbol.name : lastSymbol.name : this.splitModulePath(path).pop();
			break;
		case 1:
			var _g141 = access.sourceFileSymbol;
			var symbolChain1 = access.symbolChain;
			var path1 = access.moduleName;
			var lastSymbol1 = symbolChain1[symbolChain1.length - 1];
			typeIdentifier = lastSymbol1 != null ? tool_TsSymbolTools.isInternalSymbolName(lastSymbol1.escapedName) ? symbol.name : lastSymbol1.name : this.splitModulePath(path1).pop();
			break;
		case 2:
			var symbolChain2 = access.symbolChain;
			var lastSymbol2 = symbolChain2[symbolChain2.length - 1];
			typeIdentifier = lastSymbol2 != null ? tool_TsSymbolTools.isInternalSymbolName(lastSymbol2.escapedName) ? symbol.name : lastSymbol2.name : symbol.name;
			break;
		case 3:
			typeIdentifier = symbol.name;
			break;
		}
		var name1 = tool_HaxeTools.toSafeTypeName(typeIdentifier);
		name1 = asInterfaceStructure ? "I" + name1 : name1;
		var disallowedNames = ["Any","Array","Class","Date","DateTools","Enum","EnumValue","EReg","IntIterator","Lambda","List","Map","Math","Reflect","Std","StdTypes","String","StringBuf","StringTools","Sys","Type","UInt","UnicodeString","Xml"];
		if(disallowedNames.indexOf(name1) != -1) {
			name1 += "_";
		}
		return { name : name1, pack : pack, isExistingStdLibType : false};
	}
	,splitModulePath: function(path) {
		var _g = [];
		var _g1 = 0;
		var _g2 = haxe_io_Path.normalize(path).split("/");
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != "") {
				_g.push(v);
			}
		}
		return _g;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
var Log = function() { };
Log.__name__ = true;
Log.setPrintLogLevel = function(level) {
	Log.printLogs = level >= 3;
	Log.printWarnings = level >= 2;
	Log.printErrors = level >= 1;
};
Log.log = function(message,node,symbol,type,diagnostic) {
	var str = Log.createMessage(message,node,symbol,type,diagnostic);
	if(Log.printLogs) {
		var s = Console.logPrefix + ("" + Std.string(str));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	Log.logs.push(str);
};
Log.warn = function(message,node,symbol,type,diagnostic) {
	var str = Log.createMessage(message,node,symbol,type,diagnostic);
	if(Log.printWarnings) {
		var s = Console.warnPrefix + ("" + Std.string(str));
		var outputStream = 1;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	Log.warnings.push(str);
};
Log.error = function(message,node,symbol,type,diagnostic) {
	var str = Log.createMessage(message,node,symbol,type,diagnostic);
	if(Log.printErrors) {
		var s = Console.errorPrefix + ("" + Std.string(str));
		var outputStream = 2;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	Log.errors.push(str);
};
Log.diagnostics = function(message,array) {
	if(array == null) {
		array = [];
	}
	var _g = 0;
	while(_g < array.length) {
		var diagnostic = array[_g];
		++_g;
		switch(diagnostic.category) {
		case ts.DiagnosticCategory.Error:
			Log.error(message,null,null,null,diagnostic);
			break;
		case ts.DiagnosticCategory.Message:
			Log.log(message,null,null,null,diagnostic);
			break;
		case ts.DiagnosticCategory.Suggestion:
			Log.log(message,null,null,null,diagnostic);
			break;
		case ts.DiagnosticCategory.Warning:
			Log.warn(message,null,null,null,diagnostic);
			break;
		}
	}
};
Log.formatLocation = function(location) {
	if(location.start != null) {
		var lineAndCharacter = location.sourceFile.getLineAndCharacterOfPosition(location.start);
		var line = lineAndCharacter.line;
		var character = lineAndCharacter.character;
		return "" + location.sourceFile.fileName + ":" + (line + 1) + (character > 0 ? ":" + (character + 1) : "");
	} else {
		return "" + location.sourceFile.fileName;
	}
};
Log.symbolInfo = function(symbol) {
	var str = "<b,cyan>" + symbol.name + " " + Std.string(tool_TsSymbolTools.getFlagsInfo(symbol)) + "</>";
	if(symbol.valueDeclaration != null) {
		str += " " + Log.nodeInfo(symbol.valueDeclaration);
	} else if(symbol.declarations != null && symbol.declarations[0] != null) {
		str += " " + Log.nodeInfo(symbol.declarations[0]);
	}
	return str;
};
Log.nodeInfo = function(node) {
	var tmp = "<magenta>" + tool_TsSyntaxTools.getSyntaxKindName(node.kind) + "</>";
	var tmp1;
	try {
		tmp1 = " " + Log.formatLocation({ sourceFile : node.getSourceFile(), start : node.getStart()});
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		tmp1 = "";
	}
	return tmp + tmp1;
};
Log.typeInfo = function(type) {
	return "<blue>" + Std.string(tool_TsTypeTools.getFlagsInfo(type)) + "</>" + (type.symbol != null ? " " + Log.symbolInfo(type.symbol) : "");
};
Log.createMessage = function(arg,node,symbol,type,diagnostic) {
	var parts = [];
	if(arg != null) {
		parts.push(Std.string(arg));
	}
	if(node != null) {
		parts.push("<dim>(" + Log.nodeInfo(node) + ")</>");
	}
	if(symbol != null) {
		parts.push("<dim>(" + Log.symbolInfo(symbol) + ")</>");
	}
	if(type != null) {
		parts.push("<dim>(" + Log.typeInfo(type) + ")</>");
	}
	if(diagnostic != null) {
		var message = "<b>[TypeScript " + ts.versionMajorMinor + "]</> " + diagnostic.messageText;
		if(diagnostic.file != null) {
			message += " <dim>(" + Log.formatLocation({ sourceFile : diagnostic.file, start : diagnostic.start}) + ")</>";
		}
		parts.push(message);
	}
	return parts.join(" ");
};
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	Console.warnPrefix = "<b,yellow>> Warning:</b> ";
	Console.errorPrefix = "<b,red>> Error:</b> ";
	var userArgs = process.argv.slice(2);
	var cliOptions_tsConfigFilePath;
	var cliOptions_tsCompilerOptions;
	var cliOptions_outputPath;
	var cliOptions_noOutput;
	var cliOptions_moduleSearchPath;
	var cliOptions_moduleNames;
	var cliOptions_logLevel;
	var cliOptions_locationComments;
	var cliOptions_libWrapper;
	var cliOptions_allDependencies;
	var cliOptions_cwd = null;
	cliOptions_outputPath = "externs";
	cliOptions_tsConfigFilePath = null;
	cliOptions_tsCompilerOptions = [];
	cliOptions_moduleNames = [];
	cliOptions_moduleSearchPath = ".";
	cliOptions_allDependencies = false;
	cliOptions_noOutput = false;
	cliOptions_locationComments = false;
	cliOptions_libWrapper = true;
	cliOptions_logLevel = 1;
	var help = false;
	var noColor = false;
	var silent = false;
	var defaultValueFormatting = "yellow";
	var argHandler = { options : [{ flags : ["--output","-o"], args : [{ name : "path", opt : false, type : "String", value : null}], doc : "Set output directory for generated externs (default <" + defaultValueFormatting + ">\"" + cliOptions_outputPath + "\"</>)"},{ flags : ["--moduleSearchPath","-p"], args : [{ name : "path", opt : false, type : "String", value : null}], doc : "Path to use when searching for modules"},{ flags : ["--all"], args : [], doc : "Convert all dependencies referenced in package.json (that have type definitions)"},{ flags : ["--tsconfig"], args : [{ name : "path", opt : false, type : "String", value : null}], doc : "Set path to tsconfig file to use when processing the .d.ts files"},{ flags : ["--target"], args : [{ name : "scriptTarget", opt : false, type : "String", value : null}], doc : "Set ts compiler option `--target`, takes precedent over options provided by --tsconfig (default <" + defaultValueFormatting + ">\"ES6\"</>)"},{ flags : ["--moduleResolution"], args : [{ name : "kind", opt : false, type : "String", value : null}], doc : "Set ts compiler option `--moduleResolution`, takes precedent over options provided by --tsconfig (default <" + defaultValueFormatting + ">\"Node\"</>)"},{ flags : ["--sourceLocation"], args : [], doc : "Enables printing the corresponding source file and line number for each declaration"},{ flags : ["--noLibWrap"], args : [], doc : "Disables wrapping the generated externs in a haxelib-style library. Use this option if you intend to use the externs via a class-path rather than as a library"},{ flags : ["--noOutput"], args : [], doc : "Runs conversion but doesn't save files"},{ flags : ["--noColor"], args : [], doc : "Disable terminal colors"},{ flags : ["--no-color"], args : [], doc : null},{ flags : ["--help"], args : [], doc : "Show this help"},{ flags : ["--silent"], args : [], doc : "Disable command-line output"},{ flags : ["--noWarn"], args : [], doc : "Disable printing warnings"},{ flags : ["--verbose"], args : [], doc : "Print all logs"}], parse : function(__args) {
		var __index = 0;
		while(__index < __args.length) {
			var _g = __args[__index++];
			switch(_g) {
			case "--all":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_allDependencies = true;
				__index += 0;
				break;
			case "--help":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				help = true;
				__index += 0;
				break;
			case "--moduleResolution":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				cliOptions_tsCompilerOptions.push("--moduleResolution");
				cliOptions_tsCompilerOptions.push(__args[__index]);
				++__index;
				break;
			case "--no-color":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				noColor = true;
				__index += 0;
				break;
			case "--noColor":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				noColor = true;
				__index += 0;
				break;
			case "--noLibWrap":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_libWrapper = false;
				__index += 0;
				break;
			case "--noOutput":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_noOutput = true;
				__index += 0;
				break;
			case "--noWarn":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_logLevel = 1;
				__index += 0;
				break;
			case "--output":case "-o":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				cliOptions_outputPath = __args[__index];
				++__index;
				break;
			case "--silent":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				silent = true;
				__index += 0;
				break;
			case "--sourceLocation":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_locationComments = true;
				__index += 0;
				break;
			case "--target":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				cliOptions_tsCompilerOptions.push("--target");
				cliOptions_tsCompilerOptions.push(__args[__index]);
				++__index;
				break;
			case "--tsconfig":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				cliOptions_tsConfigFilePath = __args[__index];
				++__index;
				break;
			case "--verbose":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				cliOptions_logLevel = 4;
				__index += 0;
				break;
			case "--moduleSearchPath":case "-p":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				cliOptions_moduleSearchPath = __args[__index];
				++__index;
				break;
			default:
				var arg = _g;
				var arg1 = arg;
				if(arg1.charAt(0) == "-") {
					throw new js__$Boot_HaxeError("Unknown argument \"" + arg1 + "\"");
				}
				cliOptions_moduleNames.push(arg1);
			}
		}
	}};
	if(userArgs.length == 0) {
		Main.printDoc(argHandler);
		process.exit(1);
		return;
	} else {
		try {
			argHandler.parse(userArgs);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(typeof(e1) == "string") {
				var s = Console.errorPrefix + ("" + Std.string(e1));
				var outputStream = 2;
				if(outputStream == null) {
					outputStream = 0;
				}
				if(s == null) {
					s = "";
				}
				Console.printFormatted(s + "\n",outputStream);
				Console.print("\n");
				Main.printDoc(argHandler);
				process.exit(1);
			} else {
				throw e;
			}
		}
	}
	if(silent) {
		Console.printIntercept = function(s1,o) {
			return false;
		};
		haxe_Log.trace = function(v,info) {
			return;
		};
	}
	if(noColor) {
		Console.formatMode = 2;
	}
	if(help) {
		Main.printDoc(argHandler);
		process.exit(0);
		return;
	}
	Log.setPrintLogLevel(cliOptions_logLevel);
	var defaultCompilerOptions = ts.getDefaultCompilerOptions();
	defaultCompilerOptions.target = ts.ScriptTarget.ES2015;
	defaultCompilerOptions.types = [];
	defaultCompilerOptions.moduleResolution = ts.ModuleResolutionKind.NodeJs;
	defaultCompilerOptions.strictNullChecks = true;
	var compilerOptions = defaultCompilerOptions;
	if(cliOptions_tsConfigFilePath != null) {
		var readResult = ts.readConfigFile(cliOptions_tsConfigFilePath,function(path) {
			return ts.sys.readFile(path,"utf8");
		});
		if(readResult.config != null) {
			var compilerOptionsObj = Reflect.field(readResult.config,"compilerOptions");
			var result = ts.convertCompilerOptionsFromJson(compilerOptionsObj,process.cwd(),cliOptions_tsConfigFilePath);
			Log.diagnostics(null,result.errors);
			compilerOptions = Main.extend(compilerOptions,result.options);
		} else if(readResult.error != null) {
			Log.diagnostics(null,[readResult.error]);
		}
	}
	if(cliOptions_tsCompilerOptions.length > 0) {
		var result1 = ts.parseCommandLine(cliOptions_tsCompilerOptions);
		Log.diagnostics(null,result1.errors);
		compilerOptions = Main.extend(compilerOptions,result1.options);
	}
	var host = ts.createCompilerHost(compilerOptions);
	if(cliOptions_allDependencies) {
		try {
			var packageJson = host.readFile("package.json");
			if(packageJson == null) {
				var absPath = haxe_io_Path.join([host.getCurrentDirectory(),"package.json"]);
				throw new js__$Boot_HaxeError("<b>\"" + absPath + "\"</> does not exist; could not determine dependencies");
			}
			var packageObj = JSON.parse(packageJson);
			var dependencies = packageObj.dependencies != null ? packageObj.dependencies : { };
			var devDependencies = packageObj.devDependencies != null ? packageObj.devDependencies : { };
			var allDependencies = Reflect.fields(dependencies).concat(Reflect.fields(devDependencies));
			var _g1 = 0;
			while(_g1 < allDependencies.length) {
				var moduleName = allDependencies[_g1];
				++_g1;
				var result2 = ts.resolveModuleName(moduleName,cliOptions_moduleSearchPath + "/.",compilerOptions,host);
				if(result2.resolvedModule != null) {
					switch(result2.resolvedModule.extension) {
					case ts.Extension.Js:case ts.Extension.Json:case ts.Extension.Jsx:case ts.Extension.TsBuildInfo:
						break;
					case ts.Extension.Dts:case ts.Extension.Ts:case ts.Extension.Tsx:
						cliOptions_moduleNames.push(moduleName);
						break;
					}
					continue;
				}
				Log.warn("No type definitions found for <b>\"" + moduleName + "\"</b>");
			}
		} catch( e2 ) {
			var e3 = ((e2) instanceof js__$Boot_HaxeError) ? e2.val : e2;
			if(typeof(e3) == "string") {
				Log.error(e3);
			} else {
				throw e2;
			}
		}
	}
	var moduleQueue = new ds_OnceOnlyQueue();
	var _g2 = 0;
	var _g11 = cliOptions_moduleNames;
	while(_g2 < _g11.length) {
		var moduleName1 = _g11[_g2];
		++_g2;
		moduleQueue.tryEnqueue(moduleName1);
	}
	var _g21 = 0;
	var _g3 = ts.getAutomaticTypeDirectiveNames(compilerOptions,host);
	while(_g21 < _g3.length) {
		var moduleName2 = _g3[_g21];
		++_g21;
		moduleQueue.tryEnqueue(moduleName2);
	}
	while(true) {
		var moduleName3 = moduleQueue.dequeue();
		if(moduleName3 == null) {
			break;
		}
		var converterContext = Main.convertTsModule(moduleName3,cliOptions_moduleSearchPath,compilerOptions,cliOptions_libWrapper,cliOptions_locationComments,cliOptions_outputPath,cliOptions_noOutput);
		if(converterContext == null) {
			continue;
		}
		var moduleDependencies = converterContext.moduleDependencies;
		if(moduleDependencies.length > 0) {
			Log.log("<magenta>Module <b>" + moduleName3 + "</> depends on <b>" + Std.string(moduleDependencies) + "</></>");
		}
		var _g4 = 0;
		var _g5 = moduleDependencies;
		while(_g4 < _g5.length) {
			var moduleDependency = _g5[_g4];
			++_g4;
			moduleQueue.tryEnqueue(moduleDependency);
		}
	}
};
Main.convertTsModule = function(moduleName,moduleSearchPath,compilerOptions,libWrapper,locationComments,outputPath,noOutput) {
	var converter;
	try {
		converter = new ConverterContext(moduleName,moduleSearchPath,compilerOptions,locationComments);
	} catch( e ) {
		Log.error(((e) instanceof js__$Boot_HaxeError) ? e.val : e);
		return null;
	}
	var generateLibraryWrapper = libWrapper && !(tool_TsProgramTools.isDirectPathReferenceModule(moduleName) && converter.packageName == null);
	if(!noOutput) {
		var printer = new Printer();
		var libraryName = converter.packageName != null ? converter.packageName : converter.normalizedInputModuleName;
		var outputLibraryPath = generateLibraryWrapper ? haxe_io_Path.join([outputPath,libraryName]) : outputPath;
		var _g = new haxe_iterators_MapKeyValueIterator(converter.generatedModules);
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var _ = _g1.key;
			var haxeModule = _g1.value;
			var skipModule;
			if(haxeModule.meta != null) {
				var isValueModuleOnly = Lambda.find(haxeModule.meta,function(m) {
					return m.name == "valueModuleOnly";
				}) != null;
				skipModule = isValueModuleOnly && haxeModule.fields.length == 0;
			} else {
				skipModule = false;
			}
			if(skipModule) {
				continue;
			}
			var filePath = "" + haxeModule.name + ".hx";
			var filePath1 = haxe_io_Path.join([outputLibraryPath].concat(haxeModule.pack).concat([filePath]));
			var printPackage = true;
			var moduleHaxeStr = printer.printTypeDefinition(haxeModule,printPackage);
			Main.touchDirectoryPath(haxe_io_Path.directory(filePath1));
			js_node_Fs.writeFileSync(filePath1,moduleHaxeStr);
		}
		Main.touchDirectoryPath(outputLibraryPath);
		if(generateLibraryWrapper) {
			var packageJson = Main.getModulePackageJson(moduleName,moduleSearchPath,converter.entryPointModule);
			var readmeStr = Main.generateReadme(moduleName,moduleSearchPath,converter,packageJson);
			js_node_Fs.writeFileSync(haxe_io_Path.join([outputLibraryPath,"README.md"]),readmeStr);
			var haxelibJsonStr = Main.generateHaxelibJson(moduleName,moduleSearchPath,converter,packageJson);
			js_node_Fs.writeFileSync(haxe_io_Path.join([outputLibraryPath,"haxelib.json"]),haxelibJsonStr);
		}
		var s = Console.successPrefix + ("" + Std.string("<green>Saved externs for <b>" + moduleName + "</> into <b>" + outputLibraryPath + "/</></>"));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	return converter;
};
Main.generateReadme = function(inputModuleName,moduleSearchPath,converter,modulePackageJson) {
	var resolvedModule = converter.entryPointModule;
	var dts2hxRepoUrl = Main.dts2hxPackageJson.repository.url;
	var dts2hxRef = dts2hxRepoUrl != null ? "[dts2hx](" + dts2hxRepoUrl + ")" : "dts2hx";
	var typesModuleVersion = resolvedModule.packageId != null ? resolvedModule.packageId.version : null;
	var typesModuleName = resolvedModule.packageId != null ? resolvedModule.packageId.name : inputModuleName;
	var typesModuleUrl = modulePackageJson != null ? modulePackageJson.homepage != null ? modulePackageJson.homepage : modulePackageJson.bugs != null && modulePackageJson.bugs.url != null ? modulePackageJson.bugs.url : null : null;
	var typesModuleIdMarkdown = "" + typesModuleName + (typesModuleVersion != null ? " v" + typesModuleVersion : "");
	if(typesModuleUrl != null) {
		typesModuleIdMarkdown = "[" + typesModuleIdMarkdown + "](" + typesModuleUrl + ")";
	}
	var sections = [];
	sections.push("# Haxe Externs for " + (converter.packageName != null ? converter.packageName : converter.normalizedInputModuleName));
	sections.push("\n\t\t\tGenerated from **" + typesModuleIdMarkdown + "** by **" + dts2hxRef + " " + Main.dts2hxPackageJson.version + "** using **TypeScript " + ts.version + "** with arguments:\n\n\t\t\t\tdts2hx " + process.argv.slice(2).join(" ") + "\n\t\t");
	if(converter.moduleDependencies.length > 0) {
		var _this = converter.moduleDependencies;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "- " + _this[i];
		}
		sections.push(["## Dependencies"].concat(result).join("\n"));
	}
	if(modulePackageJson != null) {
		try {
			if(modulePackageJson.contributors != null && modulePackageJson.contributors.length > 0) {
				var tmp = "## Contributors to " + typesModuleName;
				var _this1 = modulePackageJson.contributors;
				var result1 = new Array(_this1.length);
				var _g2 = 0;
				var _g11 = _this1.length;
				while(_g2 < _g11) {
					var i1 = _g2++;
					var c = _this1[i1];
					result1[i1] = c.url != null ? "- [" + c.name + "](" + c.url + ")" : c.name;
				}
				sections.push([tmp].concat(result1).join("\n"));
			}
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		}
	}
	var result2 = new Array(sections.length);
	var _g3 = 0;
	var _g12 = sections.length;
	while(_g3 < _g12) {
		var i2 = _g3++;
		result2[i2] = StringTools.trim(tool_StringTools.removeIndentation(sections[i2]));
	}
	return result2.join("\n\n");
};
Main.generateHaxelibJson = function(inputModuleName,moduleSearchPath,converter,modulePackageJson) {
	var resolvedModule = converter.entryPointModule;
	var moduleName = converter.packageName != null ? converter.packageName : converter.normalizedInputModuleName;
	var moduleVersion = resolvedModule.packageId != null ? resolvedModule.packageId.version : null;
	var haxelib = { name : moduleName, tags : [moduleName,"externs","typescript","javascript","dts2hx"], description : "Externs for " + moduleName + (moduleVersion != null ? " v" + moduleVersion : "") + " automatically generated by dts2hx", contributors : ["haxiomic"], dependencies : { }};
	if(moduleVersion != null) {
		haxelib.version = moduleVersion;
	}
	var _g = 0;
	var _g1 = converter.moduleDependencies;
	while(_g < _g1.length) {
		var moduleDependency = _g1[_g];
		++_g;
		haxelib.dependencies[moduleDependency] = "";
	}
	return JSON.stringify(haxelib,null,"\t");
};
Main.getModulePackageJson = function(moduleName,moduleSearchPath,resolvedModule) {
	var typesModuleName = resolvedModule.packageId != null ? resolvedModule.packageId.name : moduleName;
	try {
		var packageJsonPath = require.resolve(("" + typesModuleName + "/package.json"), {paths: [moduleSearchPath]});
		return JSON.parse(js_node_Fs.readFileSync(packageJsonPath,{ encoding : "utf8"}));
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return null;
	}
};
Main.extend = function(base,extendWidth) {
	var extended = { };
	var _g = 0;
	var _g1 = Reflect.fields(base);
	while(_g < _g1.length) {
		var field = _g1[_g];
		++_g;
		extended[field] = Reflect.field(base,field);
	}
	var _g2 = 0;
	var _g3 = Reflect.fields(extendWidth);
	while(_g2 < _g3.length) {
		var field1 = _g3[_g2];
		++_g2;
		extended[field1] = Reflect.field(extendWidth,field1);
	}
	return extended;
};
Main.printDoc = function(argHandler) {
	var s = "<b>dts2hx</b> <b>" + Main.dts2hxPackageJson.version + "</> <red>alpha</> using <b>TypeScript " + ts.version + "</>";
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",0);
	var s1 = "TypeScript definition to haxe extern converter";
	if(s1 == null) {
		s1 = "";
	}
	Console.print(s1 + "\n",0);
	var s2 = "";
	if(s2 == null) {
		s2 = "";
	}
	Console.print(s2 + "\n",0);
	var s3 = "<b>Usage:</b>";
	if(s3 == null) {
		s3 = "";
	}
	Console.printFormatted(s3 + "\n",0);
	var s4 = "\tdts2hx <i,cyan>{moduleName}</> <i,cyan>{options}</>";
	if(s4 == null) {
		s4 = "";
	}
	Console.printFormatted(s4 + "\n",0);
	var s5 = "";
	if(s5 == null) {
		s5 = "";
	}
	Console.print(s5 + "\n",0);
	var s6 = "<b>Examples:</b>";
	if(s6 == null) {
		s6 = "";
	}
	Console.printFormatted(s6 + "\n",0);
	var s7 = "\tdts2hx three";
	if(s7 == null) {
		s7 = "";
	}
	Console.printFormatted(s7 + "\n",0);
	var s8 = "\tdts2hx --all -o .haxelib";
	if(s8 == null) {
		s8 = "";
	}
	Console.printFormatted(s8 + "\n",0);
	var s9 = "\tdts2hx ./src/index --verbose";
	if(s9 == null) {
		s9 = "";
	}
	Console.printFormatted(s9 + "\n",0);
	var s10 = "";
	if(s10 == null) {
		s10 = "";
	}
	Console.print(s10 + "\n",0);
	Console.printFormatted("<bright_white,b>Options:</>\n");
	var usageStringMaxLength = 0;
	var formattedOptions = [];
	var _g = 0;
	var _g1 = argHandler.options;
	while(_g < _g1.length) {
		var item = _g1[_g];
		++_g;
		if(item.doc == null) {
			continue;
		}
		var usageString = "" + item.flags.join(", ");
		if(item.args.length > 0) {
			var _this = item.args;
			var result = new Array(_this.length);
			var _g2 = 0;
			var _g11 = _this.length;
			while(_g2 < _g11) {
				var i = _g2++;
				var a = _this[i];
				result[i] = "{" + (a.opt ? "?" : "") + a.name + "}";
			}
			usageString += " <i,cyan>" + result.join(", ") + "</>";
		}
		var unformattedLength = Console.stripFormatting(usageString).length;
		formattedOptions.push({ usageString : usageString, unformattedLength : unformattedLength, doc : item.doc});
		usageStringMaxLength = Math.max(usageStringMaxLength,unformattedLength) | 0;
	}
	var result1 = new Array(formattedOptions.length);
	var _g3 = 0;
	var _g12 = formattedOptions.length;
	while(_g3 < _g12) {
		var i1 = _g3++;
		var f = formattedOptions[i1];
		var _g21 = [];
		var _g31 = 0;
		var _g4 = usageStringMaxLength - f.unformattedLength;
		while(_g31 < _g4) {
			var i2 = _g31++;
			_g21.push(" ");
		}
		var rPadding = _g21.join("");
		result1[i1] = "" + f.usageString + rPadding + " " + f.doc;
	}
	var lines = result1;
	Console.printFormatted(lines.join("\n") + "\n");
};
Main.touchDirectoryPath = function(path) {
	var directories = haxe_io_Path.normalize(path).split("/");
	var currentDirectories = [];
	var _g = 0;
	while(_g < directories.length) {
		var directory = directories[_g];
		++_g;
		currentDirectories.push(directory);
		var currentPath = currentDirectories.join("/");
		if(currentPath == "/") {
			continue;
		}
		if(js_node_Fs.existsSync(currentPath) && js_node_Fs.statSync(currentPath).isDirectory()) {
			continue;
		}
		if(!js_node_Fs.existsSync(currentPath)) {
			js_node_Fs.mkdirSync(currentPath);
		} else {
			throw new js__$Boot_HaxeError("Could not create directory " + currentPath + " because a file already exists at this path");
		}
	}
};
Math.__name__ = true;
var haxe_macro_Printer = function(tabString) {
	if(tabString == null) {
		tabString = "\t";
	}
	this.tabs = "";
	this.tabString = tabString;
};
haxe_macro_Printer.__name__ = true;
haxe_macro_Printer.prototype = {
	printUnop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		}
	}
	,printBinop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			var op1 = op.op;
			return this.printBinop(op1) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
	,escapeString: function(s,delim) {
		return delim + StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(s,"\n","\\n"),"\t","\\t"),"\r","\\r"),"'","\\'"),"\"","\\\"") + delim;
	}
	,printString: function(s) {
		return this.escapeString(s,"\"");
	}
	,printConstant: function(c) {
		switch(c._hx_index) {
		case 0:
			var s = c.v;
			return s;
		case 1:
			var s1 = c.f;
			return s1;
		case 2:
			var _g6 = c.kind;
			var s2 = c.s;
			return this.printString(s2);
		case 3:
			var s3 = c.s;
			return s3;
		case 4:
			var opt = c.opt;
			var s4 = c.r;
			return "~/" + s4 + "/" + opt;
		}
	}
	,printTypeParam: function(param) {
		switch(param._hx_index) {
		case 0:
			var ct = param.t;
			return this.printComplexType(ct);
		case 1:
			var e = param.e;
			return this.printExpr(e);
		}
	}
	,printTypePath: function(tp) {
		var tmp = (tp.pack.length > 0 ? tp.pack.join(".") + "." : "") + tp.name + (tp.sub != null ? "." + tp.sub : "");
		var tmp1;
		if(tp.params == null) {
			tmp1 = "";
		} else if(tp.params.length > 0) {
			var _this = tp.params;
			var f = $bind(this,this.printTypeParam);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp1 = "<" + result.join(", ") + ">";
		} else {
			tmp1 = "";
		}
		return tmp + tmp1;
	}
	,printComplexType: function(ct) {
		switch(ct._hx_index) {
		case 0:
			var tp = ct.p;
			return this.printTypePath(tp);
		case 1:
			var ret = ct.ret;
			var args = ct.args;
			var tmp;
			if(args.length == 1) {
				var tmp1;
				var _g = args[0];
				var tmp2;
				if(_g._hx_index == 6) {
					var _g2 = _g.t;
					var _g1 = _g.n;
					tmp2 = true;
				} else {
					tmp2 = false;
				}
				if(!tmp2) {
					var _g3 = args[0];
					if(_g3._hx_index == 1) {
						var _g5 = _g3.ret;
						var _g4 = _g3.args;
						tmp1 = true;
					} else {
						tmp1 = false;
					}
				} else {
					tmp1 = true;
				}
				tmp = !tmp1;
			} else {
				tmp = false;
			}
			if(tmp) {
				return this.printComplexType(args[0]) + " -> " + this.printComplexType(ret);
			} else {
				var f = $bind(this,this.printComplexType);
				var result = new Array(args.length);
				var _g6 = 0;
				var _g11 = args.length;
				while(_g6 < _g11) {
					var i = _g6++;
					result[i] = f(args[i]);
				}
				return "(" + result.join(", ") + ")" + " -> " + this.printComplexType(ret);
			}
			break;
		case 2:
			var fields = ct.fields;
			var _g7 = [];
			var _g12 = 0;
			while(_g12 < fields.length) {
				var f1 = fields[_g12];
				++_g12;
				_g7.push(this.printField(f1) + "; ");
			}
			return "{ " + _g7.join("") + "}";
		case 3:
			var ct1 = ct.t;
			return "(" + this.printComplexType(ct1) + ")";
		case 4:
			var fields1 = ct.fields;
			var tpl = ct.p;
			var f2 = $bind(this,this.printTypePath);
			var result1 = new Array(tpl.length);
			var _g8 = 0;
			var _g13 = tpl.length;
			while(_g8 < _g13) {
				var i1 = _g8++;
				result1[i1] = f2(tpl[i1]);
			}
			var tmp3 = "{> " + result1.join(" >, ") + ", ";
			var f3 = $bind(this,this.printField);
			var result2 = new Array(fields1.length);
			var _g9 = 0;
			var _g14 = fields1.length;
			while(_g9 < _g14) {
				var i2 = _g9++;
				result2[i2] = f3(fields1[i2]);
			}
			return tmp3 + result2.join(", ") + " }";
		case 5:
			var ct2 = ct.t;
			return "?" + this.printComplexType(ct2);
		case 6:
			var ct3 = ct.t;
			var n = ct.n;
			return n + ":" + this.printComplexType(ct3);
		case 7:
			var tl = ct.tl;
			var f4 = $bind(this,this.printComplexType);
			var result3 = new Array(tl.length);
			var _g10 = 0;
			var _g15 = tl.length;
			while(_g10 < _g15) {
				var i3 = _g10++;
				result3[i3] = f4(tl[i3]);
			}
			return result3.join(" & ");
		}
	}
	,printMetadata: function(meta) {
		return "@" + meta.name + (meta.params != null && meta.params.length > 0 ? "(" + this.printExprs(meta.params,", ") + ")" : "");
	}
	,printAccess: function(access) {
		switch(access._hx_index) {
		case 0:
			return "public";
		case 1:
			return "private";
		case 2:
			return "static";
		case 3:
			return "override";
		case 4:
			return "dynamic";
		case 5:
			return "inline";
		case 6:
			return "macro";
		case 7:
			return "final";
		case 8:
			return "extern";
		}
	}
	,printField: function(field) {
		var tmp = field.doc != null && field.doc != "" ? "/**\n" + this.tabs + this.tabString + StringTools.replace(field.doc,"\n","\n" + this.tabs + this.tabString) + "\n" + this.tabs + "**/\n" + this.tabs : "";
		var tmp1;
		if(field.meta != null && field.meta.length > 0) {
			var _this = field.meta;
			var f = $bind(this,this.printMetadata);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp1 = result.join("\n" + this.tabs) + ("\n" + this.tabs);
		} else {
			tmp1 = "";
		}
		var tmp2 = tmp + tmp1;
		var tmp3;
		if(field.access != null && field.access.length > 0) {
			var _this1 = field.access;
			var f1 = $bind(this,this.printAccess);
			var result1 = new Array(_this1.length);
			var _g2 = 0;
			var _g11 = _this1.length;
			while(_g2 < _g11) {
				var i1 = _g2++;
				result1[i1] = f1(_this1[i1]);
			}
			tmp3 = result1.join(" ") + " ";
		} else {
			tmp3 = "";
		}
		var tmp4 = tmp2 + tmp3;
		var _g3 = field.kind;
		var tmp5;
		switch(_g3._hx_index) {
		case 0:
			var eo = _g3.e;
			var t = _g3.t;
			tmp5 = (field.access != null && Lambda.has(field.access,haxe_macro_Access.AFinal) ? "" : "var ") + ("" + field.name) + this.opt(t,$bind(this,this.printComplexType)," : ") + this.opt(eo,$bind(this,this.printExpr)," = ");
			break;
		case 1:
			var func = _g3.f;
			tmp5 = "function " + field.name + this.printFunction(func);
			break;
		case 2:
			var eo1 = _g3.e;
			var t1 = _g3.t;
			var set = _g3.set;
			var get = _g3.get;
			tmp5 = "var " + field.name + "(" + get + ", " + set + ")" + this.opt(t1,$bind(this,this.printComplexType)," : ") + this.opt(eo1,$bind(this,this.printExpr)," = ");
			break;
		}
		return tmp4 + tmp5;
	}
	,printTypeParamDecl: function(tpd) {
		var tpd1 = tpd.name;
		var tmp;
		if(tpd.params != null && tpd.params.length > 0) {
			var _this = tpd.params;
			var f = $bind(this,this.printTypeParamDecl);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = "<" + result.join(", ") + ">";
		} else {
			tmp = "";
		}
		var tmp1 = tpd1 + tmp;
		var tmp2;
		if(tpd.constraints != null && tpd.constraints.length > 0) {
			var _this1 = tpd.constraints;
			var f1 = $bind(this,this.printComplexType);
			var result1 = new Array(_this1.length);
			var _g2 = 0;
			var _g11 = _this1.length;
			while(_g2 < _g11) {
				var i1 = _g2++;
				result1[i1] = f1(_this1[i1]);
			}
			tmp2 = ":(" + result1.join(", ") + ")";
		} else {
			tmp2 = "";
		}
		return tmp1 + tmp2;
	}
	,printFunctionArg: function(arg) {
		return (arg.opt ? "?" : "") + arg.name + this.opt(arg.type,$bind(this,this.printComplexType),":") + this.opt(arg.value,$bind(this,this.printExpr)," = ");
	}
	,printFunction: function(func) {
		var tmp;
		if(func.params == null) {
			tmp = "";
		} else if(func.params.length > 0) {
			var _this = func.params;
			var f = $bind(this,this.printTypeParamDecl);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = "<" + result.join(", ") + ">";
		} else {
			tmp = "";
		}
		var tmp1 = tmp + "(";
		var _this1 = func.args;
		var f1 = $bind(this,this.printFunctionArg);
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g11 = _this1.length;
		while(_g2 < _g11) {
			var i1 = _g2++;
			result1[i1] = f1(_this1[i1]);
		}
		return tmp1 + result1.join(", ") + ")" + this.opt(func.ret,$bind(this,this.printComplexType),":") + this.opt(func.expr,$bind(this,this.printExpr)," ");
	}
	,printVar: function(v) {
		return v.name + this.opt(v.type,$bind(this,this.printComplexType),":") + this.opt(v.expr,$bind(this,this.printExpr)," = ");
	}
	,printObjectFieldKey: function(of) {
		var _g = of.quotes;
		if(_g == null) {
			return of.field;
		} else {
			switch(_g._hx_index) {
			case 0:
				return of.field;
			case 1:
				return "\"" + of.field + "\"";
			}
		}
	}
	,printObjectField: function(of) {
		return "" + this.printObjectFieldKey(of) + " : " + this.printExpr(of.expr);
	}
	,printExpr: function(e) {
		var _gthis = this;
		if(e == null) {
			return "#NULL";
		} else {
			var _g = e.expr;
			switch(_g._hx_index) {
			case 0:
				var c = _g.c;
				return this.printConstant(c);
			case 1:
				var e2 = _g.e2;
				var e1 = _g.e1;
				return "" + this.printExpr(e1) + "[" + this.printExpr(e2) + "]";
			case 2:
				var e21 = _g.e2;
				var e11 = _g.e1;
				var op = _g.op;
				return "" + this.printExpr(e11) + " " + this.printBinop(op) + " " + this.printExpr(e21);
			case 3:
				var n = _g.field;
				var e12 = _g.e;
				return "" + this.printExpr(e12) + "." + n;
			case 4:
				var e13 = _g.e;
				return "(" + this.printExpr(e13) + ")";
			case 5:
				var fl = _g.fields;
				var result = new Array(fl.length);
				var _g1 = 0;
				var _g11 = fl.length;
				while(_g1 < _g11) {
					var i = _g1++;
					result[i] = _gthis.printObjectField(fl[i]);
				}
				return "{ " + result.join(", ") + " }";
			case 6:
				var el = _g.values;
				return "[" + this.printExprs(el,", ") + "]";
			case 7:
				var el1 = _g.params;
				var e14 = _g.e;
				return "" + this.printExpr(e14) + "(" + this.printExprs(el1,", ") + ")";
			case 8:
				var el2 = _g.params;
				var tp = _g.t;
				return "new " + this.printTypePath(tp) + "(" + this.printExprs(el2,", ") + ")";
			case 9:
				var _g20 = _g.e;
				var _g18 = _g.op;
				if(_g.postFix) {
					var e15 = _g20;
					var op1 = _g18;
					return this.printExpr(e15) + this.printUnop(op1);
				} else {
					var e16 = _g20;
					var op2 = _g18;
					return this.printUnop(op2) + this.printExpr(e16);
				}
				break;
			case 10:
				var vl = _g.vars;
				var f = $bind(this,this.printVar);
				var result1 = new Array(vl.length);
				var _g2 = 0;
				var _g12 = vl.length;
				while(_g2 < _g12) {
					var i1 = _g2++;
					result1[i1] = f(vl[i1]);
				}
				return "var " + result1.join(", ");
			case 11:
				var _g22 = _g.f;
				var _g21 = _g.kind;
				if(_g21 == null) {
					var func = _g22;
					return "function" + this.printFunction(func);
				} else if(_g21._hx_index == 1) {
					var func1 = _g22;
					var inlined = _g21.inlined;
					var no = _g21.name;
					return (inlined ? "inline " : "") + ("function " + no) + this.printFunction(func1);
				} else {
					var func2 = _g22;
					return "function" + this.printFunction(func2);
				}
				break;
			case 12:
				var _g25 = _g.exprs;
				if(_g25.length == 0) {
					return "{ }";
				} else {
					var el3 = _g25;
					var old = this.tabs;
					this.tabs += this.tabString;
					var s = "{\n" + this.tabs + this.printExprs(el3,";\n" + this.tabs);
					this.tabs = old;
					return s + (";\n" + this.tabs + "}");
				}
				break;
			case 13:
				var e22 = _g.expr;
				var e17 = _g.it;
				return "for (" + this.printExpr(e17) + ") " + this.printExpr(e22);
			case 14:
				var _g13 = _g.eelse;
				var _g121 = _g.eif;
				var _g111 = _g.econd;
				if(_g13 == null) {
					var econd = _g111;
					var eif = _g121;
					return "if (" + this.printExpr(econd) + ") " + this.printExpr(eif);
				} else {
					var econd1 = _g111;
					var eif1 = _g121;
					var eelse = _g13;
					return "if (" + this.printExpr(econd1) + ") " + this.printExpr(eif1) + " else " + this.printExpr(eelse);
				}
				break;
			case 15:
				var _g35 = _g.e;
				var _g34 = _g.econd;
				if(_g.normalWhile) {
					var econd2 = _g34;
					var e18 = _g35;
					return "while (" + this.printExpr(econd2) + ") " + this.printExpr(e18);
				} else {
					var econd3 = _g34;
					var e19 = _g35;
					return "do " + this.printExpr(e19) + " while (" + this.printExpr(econd3) + ")";
				}
				break;
			case 16:
				var edef = _g.edef;
				var cl = _g.cases;
				var e110 = _g.e;
				var old1 = this.tabs;
				this.tabs += this.tabString;
				var s1 = "switch " + this.printExpr(e110) + " {\n" + this.tabs;
				var result2 = new Array(cl.length);
				var _g3 = 0;
				var _g14 = cl.length;
				while(_g3 < _g14) {
					var i2 = _g3++;
					var c1 = cl[i2];
					result2[i2] = "case " + _gthis.printExprs(c1.values,", ") + (c1.guard != null ? " if (" + _gthis.printExpr(c1.guard) + "):" : ":") + (c1.expr != null ? _gthis.opt(c1.expr,$bind(_gthis,_gthis.printExpr)) + ";" : "");
				}
				var s2 = s1 + result2.join("\n" + this.tabs);
				if(edef != null) {
					s2 += "\n" + this.tabs + "default:" + (edef.expr == null ? "" : this.printExpr(edef) + ";");
				}
				this.tabs = old1;
				return s2 + ("\n" + this.tabs + "}");
			case 17:
				var cl1 = _g.catches;
				var e111 = _g.e;
				var tmp = "try " + this.printExpr(e111);
				var result3 = new Array(cl1.length);
				var _g4 = 0;
				var _g15 = cl1.length;
				while(_g4 < _g15) {
					var i3 = _g4++;
					var c2 = cl1[i3];
					result3[i3] = " catch(" + c2.name + ":" + _gthis.printComplexType(c2.type) + ") " + _gthis.printExpr(c2.expr);
				}
				return tmp + result3.join("");
			case 18:
				var eo = _g.e;
				return "return" + this.opt(eo,$bind(this,this.printExpr)," ");
			case 19:
				return "break";
			case 20:
				return "continue";
			case 21:
				var e112 = _g.e;
				return "untyped " + this.printExpr(e112);
			case 22:
				var e113 = _g.e;
				return "throw " + this.printExpr(e113);
			case 23:
				var _g41 = _g.e;
				var cto = _g.t;
				var e114 = _g41;
				if(cto != null) {
					return "cast(" + this.printExpr(e114) + ", " + this.printComplexType(cto) + ")";
				} else {
					var e115 = _g41;
					return "cast " + this.printExpr(e115);
				}
				break;
			case 24:
				var _g43 = _g.displayKind;
				var e116 = _g.e;
				return "#DISPLAY(" + this.printExpr(e116) + ")";
			case 25:
				var tp1 = _g.t;
				return "#DISPLAY(" + this.printTypePath(tp1) + ")";
			case 26:
				var eelse1 = _g.eelse;
				var eif2 = _g.eif;
				var econd4 = _g.econd;
				return "" + this.printExpr(econd4) + " ? " + this.printExpr(eif2) + " : " + this.printExpr(eelse1);
			case 27:
				var ct = _g.t;
				var e117 = _g.e;
				return "(" + this.printExpr(e117) + " : " + this.printComplexType(ct) + ")";
			case 28:
				var e118 = _g.e;
				var meta = _g.s;
				return this.printMetadata(meta) + " " + this.printExpr(e118);
			}
		}
	}
	,printExprs: function(el,sep) {
		var f = $bind(this,this.printExpr);
		var result = new Array(el.length);
		var _g = 0;
		var _g1 = el.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(el[i]);
		}
		return result.join(sep);
	}
	,printFieldWithDelimiter: function(f) {
		var tmp = this.printField(f);
		var _g = f.kind;
		var tmp1;
		switch(_g._hx_index) {
		case 0:
			var _g6 = _g.e;
			var _g5 = _g.t;
			tmp1 = ";";
			break;
		case 1:
			var _g7 = _g.f;
			var _g11 = _g7.ret;
			var _g10 = _g7.params;
			var _g9 = _g7.expr;
			var _g8 = _g7.args;
			if(_g9 == null) {
				tmp1 = ";";
			} else {
				var _g13 = _g9.pos;
				var _g12 = _g9.expr;
				if(_g12._hx_index == 12) {
					var _g14 = _g12.exprs;
					tmp1 = "";
				} else {
					tmp1 = ";";
				}
			}
			break;
		case 2:
			var _g4 = _g.e;
			var _g3 = _g.t;
			var _g2 = _g.set;
			var _g1 = _g.get;
			tmp1 = ";";
			break;
		}
		return tmp + tmp1;
	}
	,opt: function(v,f,prefix) {
		if(prefix == null) {
			prefix = "";
		}
		if(v == null) {
			return "";
		} else {
			return prefix + f(v);
		}
	}
};
var Printer = function(tabString) {
	this._multiLineStructuresStack = [];
	this._multiLineStructures = false;
	haxe_macro_Printer.call(this,tabString);
};
Printer.__name__ = true;
Printer.__super__ = haxe_macro_Printer;
Printer.prototype = $extend(haxe_macro_Printer.prototype,{
	printExtension: function(tpl,fields) {
		var _gthis = this;
		if(tpl.length == 0 && fields.length == 0) {
			return "{ }";
		}
		var printFields = function(fields1) {
			if(_gthis._multiLineStructures) {
				var _g = [];
				var _g1 = 0;
				while(_g1 < fields1.length) {
					var f = fields1[_g1];
					++_g1;
					_g.push(_gthis.tabs + _gthis.printFieldWithDelimiter(f) + "\n");
				}
				return _g.join("");
			} else {
				var _g2 = [];
				var _g11 = 0;
				while(_g11 < fields1.length) {
					var f1 = fields1[_g11];
					++_g11;
					_g2.push(_gthis.printField(f1) + "; ");
				}
				return _g2.join("");
			}
		};
		var printExtends = function(tpl1) {
			var _g3 = [];
			var _g12 = 0;
			while(_g12 < tpl1.length) {
				var tp = tpl1[_g12];
				++_g12;
				_g3.push("> " + _gthis.printTypePath(tp) + ",");
			}
			var e = _g3;
			if(_gthis._multiLineStructures) {
				var result = new Array(e.length);
				var _g4 = 0;
				var _g13 = e.length;
				while(_g4 < _g13) {
					var i = _g4++;
					result[i] = _gthis.tabs + e[i] + "\n";
				}
				return result.join("");
			} else {
				var result1 = new Array(e.length);
				var _g5 = 0;
				var _g14 = e.length;
				while(_g5 < _g14) {
					var i1 = _g5++;
					result1[i1] = e[i1] + " ";
				}
				return result1.join("");
			}
		};
		if(this._multiLineStructures) {
			var str = "{\n";
			this.tabsIndent();
			str += printExtends(tpl);
			str += printFields(fields);
			this.tabsOutdent();
			str += this.tabs + "}";
			return str;
		} else {
			return "{ " + printExtends(tpl) + printFields(fields) + "}";
		}
	}
	,printComplexType: function(ct) {
		switch(ct._hx_index) {
		case 0:
			var tp = ct.p;
			return this.printTypePath(tp);
		case 1:
			var ret = ct.ret;
			var args = ct.args;
			this._multiLineStructuresStack.push(this._multiLineStructures);
			this._multiLineStructures = false;
			var wrapArgumentsInParentheses;
			if(args.length == 1) {
				var _g = args[0];
				switch(_g._hx_index) {
				case 0:
					var _g2 = _g.p;
					wrapArgumentsInParentheses = false;
					break;
				case 3:
					var t = _g.t;
					wrapArgumentsInParentheses = false;
					break;
				case 5:
					var _g3 = _g.t;
					if(_g3._hx_index == 0) {
						var _g4 = _g3.p;
						wrapArgumentsInParentheses = false;
					} else {
						wrapArgumentsInParentheses = true;
					}
					break;
				default:
					wrapArgumentsInParentheses = true;
				}
			} else {
				wrapArgumentsInParentheses = true;
			}
			var f = $bind(this,this.printComplexType);
			var result = new Array(args.length);
			var _g1 = 0;
			var _g11 = args.length;
			while(_g1 < _g11) {
				var i = _g1++;
				result[i] = f(args[i]);
			}
			var argStr = result.join(", ");
			var ret1;
			if(ret._hx_index == 1) {
				var _g6 = ret.ret;
				var _g5 = ret.args;
				ret1 = "(" + this.printComplexType(ret) + ")";
			} else {
				ret1 = this.printComplexType(ret);
			}
			var ret2 = (wrapArgumentsInParentheses ? "(" + argStr + ")" : argStr) + " -> " + ret1;
			this._multiLineStructures = this._multiLineStructuresStack.pop();
			return ret2;
		case 2:
			var fields = ct.fields;
			return this.printExtension([],fields);
		case 3:
			var ct1 = ct.t;
			return "(" + this.printComplexType(ct1) + ")";
		case 4:
			var fields1 = ct.fields;
			var tpl = ct.p;
			return this.printExtension(tpl,fields1);
		case 5:
			var ct2 = ct.t;
			return "?" + this.printComplexType(ct2);
		case 6:
			var ct3 = ct.t;
			var n = ct.n;
			return n + ":" + this.printComplexType(ct3);
		case 7:
			var tl = ct.tl;
			var f1 = $bind(this,this.printComplexType);
			var result1 = new Array(tl.length);
			var _g7 = 0;
			var _g12 = tl.length;
			while(_g7 < _g12) {
				var i1 = _g7++;
				result1[i1] = f1(tl[i1]);
			}
			return result1.join(" & ");
		}
	}
	,printField: function(field) {
		var metaSeparator = this._multiLineStructures ? "\n" + this.tabs : " ";
		var tmp = field.doc != null && field.doc != "" ? "/**" + (this._multiLineStructures ? "\n" + this.tabs + this.tabString : " ") + StringTools.replace(field.doc,"\n",this._multiLineStructures ? "\n" + this.tabs + this.tabString : "") + (this._multiLineStructures ? "\n" + this.tabs : " ") + "**/" + (this._multiLineStructures ? "\n" + this.tabs : " ") : "";
		var tmp1;
		if(field.meta != null && field.meta.length > 0) {
			var _this = field.meta;
			var f = $bind(this,this.printMetadata);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp1 = result.join(metaSeparator) + metaSeparator;
		} else {
			tmp1 = "";
		}
		var tmp2 = tmp + tmp1;
		var tmp3;
		if(field.access != null && field.access.length > 0) {
			var access = field.access;
			var _this1;
			if(Lambda.has(access,haxe_macro_Access.AFinal)) {
				var _g2 = [];
				var _g11 = 0;
				var _g21 = access;
				while(_g11 < _g21.length) {
					var v = _g21[_g11];
					++_g11;
					if(v._hx_index != 7) {
						_g2.push(v);
					}
				}
				_this1 = _g2.concat([haxe_macro_Access.AFinal]);
			} else {
				_this1 = access;
			}
			var f1 = $bind(this,this.printAccess);
			var result1 = new Array(_this1.length);
			var _g3 = 0;
			var _g12 = _this1.length;
			while(_g3 < _g12) {
				var i1 = _g3++;
				result1[i1] = f1(_this1[i1]);
			}
			tmp3 = result1.join(" ") + " ";
		} else {
			tmp3 = "";
		}
		var tmp4 = tmp2 + tmp3;
		var _g4 = field.kind;
		var tmp5;
		switch(_g4._hx_index) {
		case 0:
			var eo = _g4.e;
			var t = _g4.t;
			tmp5 = (field.access != null && Lambda.has(field.access,haxe_macro_Access.AFinal) ? "" : "var ") + ("" + field.name) + this.opt(t,$bind(this,this.printComplexType)," : ") + this.opt(eo,$bind(this,this.printExpr)," = ");
			break;
		case 1:
			var func = _g4.f;
			tmp5 = "function " + field.name + this.printFunction(func);
			break;
		case 2:
			var eo1 = _g4.e;
			var t1 = _g4.t;
			var set = _g4.set;
			var get = _g4.get;
			tmp5 = "var " + field.name + "(" + get + ", " + set + ")" + this.opt(t1,$bind(this,this.printComplexType)," : ") + this.opt(eo1,$bind(this,this.printExpr)," = ");
			break;
		}
		return tmp4 + tmp5;
	}
	,printTypeDefinition: function(t,printPackage) {
		if(printPackage == null) {
			printPackage = true;
		}
		var str;
		if(t == null) {
			str = "#NULL";
		} else {
			var str1 = (printPackage && t.pack.length > 0 && t.pack[0] != "" ? "package " + t.pack.join(".") + ";\n" : "") + (t.doc != null && t.doc != "" ? "/**\n" + this.tabString + StringTools.replace(t.doc,"\n","\n" + this.tabString) + "\n**/\n" : "");
			var str2;
			if(t.meta != null && t.meta.length > 0) {
				var _this = t.meta;
				var f = $bind(this,this.printMetadata);
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = f(_this[i]);
				}
				str2 = result.join(" ") + " ";
			} else {
				str2 = "";
			}
			var str3 = str1 + str2 + (t.isExtern ? "extern " : "");
			var _g2 = t.kind;
			var str4;
			switch(_g2._hx_index) {
			case 0:
				var str5 = "enum " + t.name;
				var str6;
				if(t.params != null && t.params.length > 0) {
					var _this1 = t.params;
					var f1 = $bind(this,this.printTypeParamDecl);
					var result1 = new Array(_this1.length);
					var _g3 = 0;
					var _g11 = _this1.length;
					while(_g3 < _g11) {
						var i1 = _g3++;
						result1[i1] = f1(_this1[i1]);
					}
					str6 = "<" + result1.join(", ") + ">";
				} else {
					str6 = "";
				}
				this._multiLineStructuresStack.push(this._multiLineStructures);
				this._multiLineStructures = true;
				var ret = this.printExtension([],t.fields);
				this._multiLineStructures = this._multiLineStructuresStack.pop();
				str4 = str5 + str6 + " " + ret;
				break;
			case 1:
				var str7 = "typedef " + t.name;
				var str8;
				if(t.params != null && t.params.length > 0) {
					var _this2 = t.params;
					var f2 = $bind(this,this.printTypeParamDecl);
					var result2 = new Array(_this2.length);
					var _g4 = 0;
					var _g12 = _this2.length;
					while(_g4 < _g12) {
						var i2 = _g4++;
						result2[i2] = f2(_this2[i2]);
					}
					str8 = "<" + result2.join(", ") + ">";
				} else {
					str8 = "";
				}
				this._multiLineStructuresStack.push(this._multiLineStructures);
				this._multiLineStructures = true;
				var ret1 = this.printExtension([],t.fields);
				this._multiLineStructures = this._multiLineStructuresStack.pop();
				str4 = str7 + str8 + " = " + ret1;
				break;
			case 2:
				var isFinal = _g2.isFinal;
				var isInterface = _g2.isInterface;
				var interfaces = _g2.interfaces;
				var superClass = _g2.superClass;
				var str9 = (isFinal ? "final " : "") + (isInterface ? "interface " : "class ") + t.name;
				var str10;
				if(t.params != null && t.params.length > 0) {
					var _this3 = t.params;
					var f3 = $bind(this,this.printTypeParamDecl);
					var result3 = new Array(_this3.length);
					var _g5 = 0;
					var _g13 = _this3.length;
					while(_g5 < _g13) {
						var i3 = _g5++;
						result3[i3] = f3(_this3[i3]);
					}
					str10 = "<" + result3.join(", ") + ">";
				} else {
					str10 = "";
				}
				var str11 = str9 + str10 + (superClass != null ? " extends " + this.printTypePath(superClass) : "");
				var str12;
				if(interfaces != null) {
					var str13;
					if(isInterface) {
						var _g6 = [];
						var _g14 = 0;
						while(_g14 < interfaces.length) {
							var tp = interfaces[_g14];
							++_g14;
							_g6.push(" extends " + this.printTypePath(tp));
						}
						str13 = _g6;
					} else {
						var _g7 = [];
						var _g15 = 0;
						while(_g15 < interfaces.length) {
							var tp1 = interfaces[_g15];
							++_g15;
							_g7.push(" implements " + this.printTypePath(tp1));
						}
						str13 = _g7;
					}
					str12 = str13.join("");
				} else {
					str12 = "";
				}
				this._multiLineStructuresStack.push(this._multiLineStructures);
				this._multiLineStructures = true;
				var ret2 = this.printExtension([],t.fields);
				this._multiLineStructures = this._multiLineStructuresStack.pop();
				str4 = str11 + str12 + " " + ret2;
				break;
			case 3:
				var ct = _g2.t;
				var str14 = "typedef " + t.name;
				var str15;
				if(t.params != null && t.params.length > 0) {
					var _this4 = t.params;
					var f4 = $bind(this,this.printTypeParamDecl);
					var result4 = new Array(_this4.length);
					var _g8 = 0;
					var _g16 = _this4.length;
					while(_g8 < _g16) {
						var i4 = _g8++;
						result4[i4] = f4(_this4[i4]);
					}
					str15 = "<" + result4.join(", ") + ">";
				} else {
					str15 = "";
				}
				var str16 = str14 + str15 + " = ";
				this._multiLineStructuresStack.push(this._multiLineStructures);
				this._multiLineStructures = true;
				var ret3;
				switch(ct._hx_index) {
				case 2:
					var fields = ct.fields;
					ret3 = this.printExtension([],fields);
					break;
				case 4:
					var fields1 = ct.fields;
					var tpl = ct.p;
					ret3 = this.printExtension(tpl,fields1);
					break;
				default:
					ret3 = this.printComplexType(ct);
				}
				this._multiLineStructures = this._multiLineStructuresStack.pop();
				str4 = str16 + ret3 + ";";
				break;
			case 4:
				var to = _g2.to;
				var from = _g2.from;
				var tthis = _g2.tthis;
				var str17 = "abstract " + t.name;
				var str18;
				if(t.params != null && t.params.length > 0) {
					var _this5 = t.params;
					var f5 = $bind(this,this.printTypeParamDecl);
					var result5 = new Array(_this5.length);
					var _g9 = 0;
					var _g17 = _this5.length;
					while(_g9 < _g17) {
						var i5 = _g9++;
						result5[i5] = f5(_this5[i5]);
					}
					str18 = "<" + result5.join(", ") + ">";
				} else {
					str18 = "";
				}
				var str19 = str17 + str18 + (tthis == null ? "" : "(" + this.printComplexType(tthis) + ")");
				var str20;
				if(from == null) {
					str20 = "";
				} else {
					var _g10 = [];
					var _g18 = 0;
					while(_g18 < from.length) {
						var f6 = from[_g18];
						++_g18;
						_g10.push(" from " + this.printComplexType(f6));
					}
					str20 = _g10.join("");
				}
				var str21 = str19 + str20;
				var str22;
				if(to == null) {
					str22 = "";
				} else {
					var _g19 = [];
					var _g110 = 0;
					while(_g110 < to.length) {
						var t1 = to[_g110];
						++_g110;
						_g19.push(" to " + this.printComplexType(t1));
					}
					str22 = _g19.join("");
				}
				this._multiLineStructuresStack.push(this._multiLineStructures);
				this._multiLineStructures = true;
				var ret4 = this.printExtension([],t.fields);
				this._multiLineStructures = this._multiLineStructuresStack.pop();
				str4 = str21 + str22 + " " + ret4;
				break;
			}
			str = str3 + str4;
		}
		return str;
	}
	,printFunctionArg: function(func) {
		this._multiLineStructuresStack.push(this._multiLineStructures);
		this._multiLineStructures = false;
		var ret = haxe_macro_Printer.prototype.printFunctionArg.call(this,func);
		this._multiLineStructures = this._multiLineStructuresStack.pop();
		return ret;
	}
	,tabsIndent: function() {
		this.tabs += this.tabString;
	}
	,tabsOutdent: function() {
		this.tabs = HxOverrides.substr(this.tabs,0,this.tabs.length - 1);
	}
});
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var SupportTypes = function() { };
SupportTypes.__name__ = true;
SupportTypes.getTupleType = function(ctx,elementTypes) {
	if(elementTypes.length == 0) {
		return haxe_macro_ComplexType.TPath({ pack : ["std"], name : "Array", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
	}
	var typePath = "Tuple" + elementTypes.length;
	var result = new Array(elementTypes.length);
	var _g = 0;
	var _g1 = elementTypes.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = haxe_macro_TypeParam.TPType(elementTypes[i]);
	}
	var typePath1 = { pack : ["ts"], name : typePath, params : result};
	var existingModule = ctx.getGeneratedModule(typePath1);
	if(existingModule == null) {
		var fields = [];
		var _g2 = 0;
		var _g11 = elementTypes.length;
		while(_g2 < _g11) {
			var i1 = _g2++;
			var name = "element" + i1;
			var type = haxe_macro_ComplexType.TPath({ name : "T" + i1, pack : []});
			var get = "get_" + name;
			var set = "set_" + name;
			var indexExpr = tool_HaxeTools.toIntExpr(i1);
			var inlobj_name = "";
			var inlobj_pos_file = "src/SupportTypes.hx";
			var inlobj_pos_min = 1039;
			var inlobj_pos_max = 1239;
			var inlobj_isExtern = false;
			var inlobj_kind = haxe_macro_TypeDefKind.TDClass(null,[],false,false);
			var inlobj_fields = [{ name : name, access : [haxe_macro_Access.APublic], kind : haxe_macro_FieldType.FProp("get","set",type,null), pos : { file : "src/SupportTypes.hx", min : 1052, max : 1086}},{ name : get, access : [haxe_macro_Access.AInline], kind : haxe_macro_FieldType.FFun({ args : [], ret : type, expr : { expr : haxe_macro_ExprDef.EReturn({ expr : haxe_macro_ExprDef.ECast({ expr : haxe_macro_ExprDef.EArray({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("this")), pos : { file : "src/SupportTypes.hx", min : 1134, max : 1138}},indexExpr), pos : { file : "src/SupportTypes.hx", min : 1134, max : 1150}},null), pos : { file : "src/SupportTypes.hx", min : 1129, max : 1150}}), pos : { file : "src/SupportTypes.hx", min : 1122, max : 1150}}, params : []}), pos : { file : "src/SupportTypes.hx", min : 1092, max : 1150}},{ name : set, access : [haxe_macro_Access.AInline], kind : haxe_macro_FieldType.FFun({ args : [{ name : "v", opt : false, type : type}], ret : type, expr : { expr : haxe_macro_ExprDef.EReturn({ expr : haxe_macro_ExprDef.ECast({ expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAssign,{ expr : haxe_macro_ExprDef.EArray({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("this")), pos : { file : "src/SupportTypes.hx", min : 1207, max : 1211}},indexExpr), pos : { file : "src/SupportTypes.hx", min : 1207, max : 1223}},{ expr : haxe_macro_ExprDef.ECast({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("v")), pos : { file : "src/SupportTypes.hx", min : 1231, max : 1232}},null), pos : { file : "src/SupportTypes.hx", min : 1226, max : 1232}}), pos : { file : "src/SupportTypes.hx", min : 1207, max : 1232}},null), pos : { file : "src/SupportTypes.hx", min : 1202, max : 1232}}), pos : { file : "src/SupportTypes.hx", min : 1195, max : 1232}}, params : []}), pos : { file : "src/SupportTypes.hx", min : 1157, max : 1232}}];
			fields = fields.concat(inlobj_fields);
		}
		var _g21 = [];
		var _g3 = 0;
		var _g4 = elementTypes.length;
		while(_g3 < _g4) {
			var i2 = _g3++;
			_g21.push("element" + i2 + ":T" + i2);
		}
		var newParams = _g21.join(", ");
		var _g5 = [];
		var _g6 = 0;
		var _g7 = elementTypes.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			_g5.push({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("element" + i3)), pos : { file : "src/SupportTypes.hx", min : 1436, max : 1449}});
		}
		var elementInitializerArray = _g5;
		var inlobj_name1 = "";
		var inlobj_pos_file1 = "src/SupportTypes.hx";
		var inlobj_pos_min1 = 1477;
		var inlobj_pos_max1 = 1581;
		var inlobj_isExtern1 = false;
		var inlobj_kind1 = haxe_macro_TypeDefKind.TDClass(null,[],false,false);
		var inlobj_fields_0 = { name : "new", access : [haxe_macro_Access.APublic,haxe_macro_Access.AInline], kind : haxe_macro_FieldType.FFun({ args : [{ name : newParams, opt : false, type : null}], ret : null, expr : { expr : haxe_macro_ExprDef.EBlock([{ expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAssign,{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("this")), pos : { file : "src/SupportTypes.hx", min : 1535, max : 1539}},{ expr : haxe_macro_ExprDef.EArrayDecl(elementInitializerArray), pos : { file : "src/SupportTypes.hx", min : 1544, max : 1569}}), pos : { file : "src/SupportTypes.hx", min : 1535, max : 1569}}]), pos : { file : "src/SupportTypes.hx", min : 1528, max : 1576}}, params : []}), pos : { file : "src/SupportTypes.hx", min : 1489, max : 1576}};
		fields.unshift(inlobj_fields_0);
		var abstractType = haxe_macro_ComplexType.TPath({ pack : ["std"], name : "Array", params : [haxe_macro_TypeParam.TPType(haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []}))]});
		var typePath2 = typePath1.pack;
		var typePath3 = typePath1.name;
		var tupleTypeDefinition = haxe_macro_TypeDefKind.TDAbstract(abstractType,[abstractType],[abstractType]);
		var _g8 = [];
		var _g9 = 0;
		var _g10 = elementTypes.length;
		while(_g9 < _g10) {
			var i4 = _g9++;
			_g8.push({ name : "T" + i4});
		}
		var tupleTypeDefinition1 = { pack : typePath2, name : typePath3, kind : tupleTypeDefinition, params : _g8, fields : fields, isExtern : true, doc : "Tuple type implementation generated by dts2hx", meta : [{ name : ":forward", pos : null},{ name : ":forwardStatics", pos : null}], pos : null, tsSymbol : null, tsSymbolAccess : null};
		ctx.saveHaxeModule(tupleTypeDefinition1);
	}
	return haxe_macro_ComplexType.TPath(typePath1);
};
SupportTypes.getUnionType = function(ctx,types) {
	if(types.length == 0) {
		Log.error("getSupportUnionType(): no types provided");
		debugger;
		return haxe_macro_ComplexType.TPath({ pack : [], name : "Any", params : []});
	}
	if(types.length == 1) {
		return types[0];
	}
	var typePath = "AnyOf" + types.length;
	var result = new Array(types.length);
	var _g = 0;
	var _g1 = types.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = haxe_macro_TypeParam.TPType(types[i]);
	}
	var typePath1 = { pack : ["ts"], name : typePath, params : result};
	var existingModule = ctx.getGeneratedModule(typePath1);
	if(existingModule == null) {
		var abstractType = haxe_macro_ComplexType.TPath({ pack : [], name : "Dynamic", params : []});
		var _g2 = [];
		var _g11 = 0;
		var _g21 = types.length;
		while(_g11 < _g21) {
			var i1 = _g11++;
			_g2.push(haxe_macro_ComplexType.TPath({ pack : [], name : "T" + i1}));
		}
		var typeParams = _g2;
		var typePath2 = typePath1.pack;
		var typePath3 = typePath1.name;
		var anyOfTypeDefinition = haxe_macro_TypeDefKind.TDAbstract(abstractType,typeParams,typeParams);
		var _g3 = [];
		var _g4 = 0;
		var _g5 = types.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			_g3.push({ name : "T" + i2});
		}
		var anyOfTypeDefinition1 = { pack : typePath2, name : typePath3, kind : anyOfTypeDefinition, params : _g3, fields : [], isExtern : true, doc : "AnyOf implementation generated by dts2hx", meta : [], pos : null, tsSymbol : null, tsSymbolAccess : null};
		ctx.saveHaxeModule(anyOfTypeDefinition1);
	}
	return haxe_macro_ComplexType.TPath(typePath1);
};
SupportTypes.getGlobalModuleForFieldSymbol = function(ctx,symbol,access) {
	var typePath = ctx.haxeTypePathMap.getGlobalModuleTypePath(symbol,access);
	var existingModule = ctx.getGeneratedModule({ name : typePath.name, pack : typePath.pack});
	if(existingModule != null) {
		return existingModule;
	}
	var hxModule = { pack : typePath.pack, name : typePath.name, fields : [], kind : haxe_macro_TypeDefKind.TDClass(null,[],false,false), params : [], isExtern : true, doc : "", meta : [tool_SymbolAccessTools.toAccessMetadata(SymbolAccess.Global([]))], pos : null, tsSymbol : symbol, tsSymbolAccess : access};
	ctx.saveHaxeModule(hxModule);
	return hxModule;
};
var SymbolAccess = $hxEnums["SymbolAccess"] = { __ename__ : true, __constructs__ : ["AmbientModule","ExportModule","Global","Inaccessible"]
	,AmbientModule: ($_=function(modulePath,moduleSymbol,symbolChain) { return {_hx_index:0,modulePath:modulePath,moduleSymbol:moduleSymbol,symbolChain:symbolChain,__enum__:"SymbolAccess",toString:$estr}; },$_.__params__ = ["modulePath","moduleSymbol","symbolChain"],$_)
	,ExportModule: ($_=function(moduleName,sourceFileSymbol,symbolChain) { return {_hx_index:1,moduleName:moduleName,sourceFileSymbol:sourceFileSymbol,symbolChain:symbolChain,__enum__:"SymbolAccess",toString:$estr}; },$_.__params__ = ["moduleName","sourceFileSymbol","symbolChain"],$_)
	,Global: ($_=function(symbolChain) { return {_hx_index:2,symbolChain:symbolChain,__enum__:"SymbolAccess",toString:$estr}; },$_.__params__ = ["symbolChain"],$_)
	,Inaccessible: {_hx_index:3,__enum__:"SymbolAccess",toString:$estr}
};
var SymbolAccessMap = function(program,moduleRootSourceFiles) {
	this.symbolAccessMap = new haxe_ds_IntMap();
	var _gthis = this;
	this.tc = program.getTypeChecker();
	var _g = 0;
	while(_g < moduleRootSourceFiles.length) {
		var moduleSourceFile = moduleRootSourceFiles[_g];
		++_g;
		tool_TsProgramTools.walkReferencedSourceFiles(program,moduleSourceFile,function(sourceFile) {
			var sourceFileSymbol = _gthis.tc.getSymbolAtLocation(sourceFile);
			var _g1 = 0;
			var _g11 = tool_TsProgramTools.getGlobalScopeSymbolsInSourceFile(program,sourceFile);
			while(_g1 < _g11.length) {
				var symbol = _g11[_g1];
				++_g1;
				tool_TsSymbolTools.walkDeclarationSymbols(_gthis.tc,symbol,function(symbol1,accessChain) {
					var currentAccess = SymbolAccess.Global([]);
					var _g2 = 0;
					var _g12 = accessChain;
					while(_g2 < _g12.length) {
						var s = _g12[_g2];
						++_g2;
						currentAccess = _gthis.symbolAccessAppendSymbol(currentAccess,s);
					}
					_gthis.setAccess(symbol1,currentAccess);
					return;
				});
			}
			if(sourceFileSymbol != null) {
				tool_TsSymbolTools.walkDeclarationSymbols(_gthis.tc,sourceFileSymbol,function(symbol2,accessChain1) {
					var moduleName = sourceFile.moduleName;
					if(moduleName == null) {
						Log.error("Internal error: SourceFile.moduleName was null, this should have been set when ConverterContext initialized",sourceFile);
					}
					var currentAccess1 = SymbolAccess.ExportModule(moduleName,sourceFileSymbol,[]);
					var _g21 = 0;
					var _g3 = accessChain1;
					while(_g21 < _g3.length) {
						var s1 = _g3[_g21];
						++_g21;
						currentAccess1 = _gthis.symbolAccessAppendSymbol(currentAccess1,s1);
					}
					_gthis.setAccess(symbol2,currentAccess1);
					return;
				});
			}
			return;
		});
	}
};
SymbolAccessMap.__name__ = true;
SymbolAccessMap.prototype = {
	getAccess: function(symbol) {
		var this1 = this.symbolAccessMap;
		var key = tool_TsSymbolTools.getId(symbol);
		var accessArray = this1.h[key];
		if(accessArray != null && accessArray.length > 0) {
			return accessArray;
		} else {
			return [SymbolAccess.Inaccessible];
		}
	}
	,setAccess: function(symbol,access) {
		var this1 = this.symbolAccessMap;
		var key = tool_TsSymbolTools.getId(symbol);
		var accessArray = this1.h[key];
		if(accessArray == null) {
			accessArray = [];
			var this2 = this.symbolAccessMap;
			var key1 = tool_TsSymbolTools.getId(symbol);
			this2.h[key1] = accessArray;
		}
		switch(access._hx_index) {
		case 0:
			var _g2 = access.symbolChain;
			var _g1 = access.moduleSymbol;
			var path = access.modulePath;
			var _g = [];
			var _g11 = 0;
			var _g21 = accessArray;
			while(_g11 < _g21.length) {
				var v = _g21[_g11];
				++_g11;
				var tmp;
				switch(v._hx_index) {
				case 0:
					var _g22 = v.symbolChain;
					var _g12 = v.moduleSymbol;
					var _g3 = v.modulePath;
					tmp = true;
					break;
				case 1:
					var _g5 = v.symbolChain;
					var _g4 = v.sourceFileSymbol;
					var _g31 = v.moduleName;
					tmp = true;
					break;
				default:
					tmp = false;
				}
				if(tmp) {
					_g.push(v);
				}
			}
			var existingAccess = _g;
			if(existingAccess.length == 0) {
				accessArray.push(access);
			} else {
				var removed = false;
				var _g6 = 0;
				while(_g6 < existingAccess.length) {
					var a = existingAccess[_g6];
					++_g6;
					var existingPath;
					switch(a._hx_index) {
					case 0:
						var _g23 = a.symbolChain;
						var _g13 = a.moduleSymbol;
						var p = a.modulePath;
						existingPath = p;
						break;
					case 1:
						var _g51 = a.symbolChain;
						var _g41 = a.sourceFileSymbol;
						var p1 = a.moduleName;
						existingPath = p1;
						break;
					default:
						throw new js__$Boot_HaxeError("Internal error");
					}
					if(path.length < existingPath.length) {
						HxOverrides.remove(accessArray,a);
						removed = true;
					}
				}
				if(removed) {
					accessArray.push(access);
				}
			}
			break;
		case 1:
			var _g61 = access.symbolChain;
			var _g52 = access.sourceFileSymbol;
			var path1 = access.moduleName;
			var _g7 = [];
			var _g14 = 0;
			var _g24 = accessArray;
			while(_g14 < _g24.length) {
				var v1 = _g24[_g14];
				++_g14;
				var tmp1;
				switch(v1._hx_index) {
				case 0:
					var _g25 = v1.symbolChain;
					var _g15 = v1.moduleSymbol;
					var _g8 = v1.modulePath;
					tmp1 = true;
					break;
				case 1:
					var _g53 = v1.symbolChain;
					var _g42 = v1.sourceFileSymbol;
					var _g32 = v1.moduleName;
					tmp1 = true;
					break;
				default:
					tmp1 = false;
				}
				if(tmp1) {
					_g7.push(v1);
				}
			}
			var existingAccess1 = _g7;
			if(existingAccess1.length == 0) {
				accessArray.push(access);
			} else {
				var removed1 = false;
				var _g9 = 0;
				while(_g9 < existingAccess1.length) {
					var a1 = existingAccess1[_g9];
					++_g9;
					var existingPath1;
					switch(a1._hx_index) {
					case 0:
						var _g26 = a1.symbolChain;
						var _g16 = a1.moduleSymbol;
						var p2 = a1.modulePath;
						existingPath1 = p2;
						break;
					case 1:
						var _g54 = a1.symbolChain;
						var _g43 = a1.sourceFileSymbol;
						var p3 = a1.moduleName;
						existingPath1 = p3;
						break;
					default:
						throw new js__$Boot_HaxeError("Internal error");
					}
					if(path1.length < existingPath1.length) {
						HxOverrides.remove(accessArray,a1);
						removed1 = true;
					}
				}
				if(removed1) {
					accessArray.push(access);
				}
			}
			break;
		case 2:
			var _g33 = access.symbolChain;
			var _g10 = [];
			var _g17 = 0;
			var _g27 = accessArray;
			while(_g17 < _g27.length) {
				var v2 = _g27[_g17];
				++_g17;
				var tmp2;
				if(v2._hx_index == 2) {
					var _g18 = v2.symbolChain;
					tmp2 = true;
				} else {
					tmp2 = false;
				}
				if(tmp2) {
					_g10.push(v2);
				}
			}
			if(_g10.length == 0) {
				accessArray.push(access);
			}
			break;
		case 3:
			break;
		}
	}
	,symbolAccessAppendSymbol: function(access,symbol) {
		if(symbol.escapedName == ts.InternalSymbolName.ExportEquals) {
			Log.error("Internal error: `export=` symbol should not appear in a symbol access chain (" + tool_SymbolAccessTools.toString(access) + ")",null,symbol);
		}
		var symbolChain = tool_SymbolAccessTools.extractSymbolChain(access);
		var _g1 = 0;
		var _g2 = symbolChain.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var existingSymbol = symbolChain[i];
			if((existingSymbol.flags & ts.SymbolFlags.Alias) != 0 && this.tc.getAliasedSymbol(existingSymbol) == symbol) {
				switch(access._hx_index) {
				case 0:
					var s = access.symbolChain;
					var r = access.moduleSymbol;
					var m = access.modulePath;
					return SymbolAccess.AmbientModule(m,r,s.slice(0,i + 1));
				case 1:
					var s1 = access.symbolChain;
					var r1 = access.sourceFileSymbol;
					var m1 = access.moduleName;
					return SymbolAccess.ExportModule(m1,r1,s1.slice(0,i + 1));
				case 2:
					var s2 = access.symbolChain;
					return SymbolAccess.Global(s2.slice(0,i + 1));
				case 3:
					return SymbolAccess.Inaccessible;
				}
			}
		}
		if(tool_TsSymbolTools.isSourceFileSymbol(symbol)) {
			switch(access._hx_index) {
			case 0:
				var _g5 = access.symbolChain;
				var _g4 = access.moduleSymbol;
				var path = access.modulePath;
				Log.error("Cannot change symbol access from <b>AmbientModule(" + path + ")</> to ExportModule",null,symbol);
				return access;
			case 1:
				var _g9 = access.symbolChain;
				var sourceFileSymbol = access.sourceFileSymbol;
				var moduleName = access.moduleName;
				if(symbol != sourceFileSymbol) {
					Log.error("Cannot change symbol access module from <b>ExportModule(" + moduleName + ", " + sourceFileSymbol.name + ")</> to ExportModule",null,symbol);
				}
				return SymbolAccess.ExportModule(moduleName,sourceFileSymbol,[]);
			case 2:
				var _g6 = access.symbolChain;
				Log.error("Cannot change symbol access from global to module",null,symbol);
				return access;
			case 3:
				return SymbolAccess.ExportModule(symbol.name,symbol,[]);
			}
		} else if(tool_TsSymbolTools.isExternalModuleSymbol(symbol)) {
			switch(access._hx_index) {
			case 0:
				var _g51 = access.symbolChain;
				var _g41 = access.moduleSymbol;
				var _g3 = access.modulePath;
				Log.warn("Nested ambient modules should be impossible. This might indicate an internal error",null,symbol);
				return SymbolAccess.AmbientModule(symbol.name,symbol,[]);
			case 1:
				var _g91 = access.symbolChain;
				var rootSourceFileSymbol = access.sourceFileSymbol;
				var rootModuleName = access.moduleName;
				Log.error("Cannot change symbol access from <b>ExportModule(" + rootModuleName + ", " + rootSourceFileSymbol.name + ")</> to <b>AmbientModule(\"" + symbol.name + "\")</>",null,symbol);
				return access;
			case 2:
				var _g61 = access.symbolChain;
				return SymbolAccess.AmbientModule(symbol.name,symbol,[]);
			case 3:
				return SymbolAccess.AmbientModule(symbol.name,symbol,[]);
			}
		} else {
			if((symbol.flags & ts.SymbolFlags.Alias) != 0) {
				var aliasedSymbol = this.tc.getAliasedSymbol(symbol);
				if(tool_TsSymbolTools.isSourceFileSymbol(aliasedSymbol)) {
					return this.symbolAccessAppendSymbol(access,aliasedSymbol);
				}
			}
			switch(access._hx_index) {
			case 0:
				var s3 = access.symbolChain;
				var r2 = access.moduleSymbol;
				var m2 = access.modulePath;
				return SymbolAccess.AmbientModule(m2,r2,s3.concat([symbol]));
			case 1:
				var s4 = access.symbolChain;
				var r3 = access.sourceFileSymbol;
				var m3 = access.moduleName;
				return SymbolAccess.ExportModule(m3,r3,s4.concat([symbol]));
			case 2:
				var s5 = access.symbolChain;
				return SymbolAccess.Global(s5.concat([symbol]));
			case 3:
				return SymbolAccess.Inaccessible;
			}
		}
	}
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
});
var TsInternal = function() { };
TsInternal.__name__ = true;
TsInternal.getSourceFileFromReference = function(program,sourceFile,fileReference) {
	return program.getSourceFileFromReference(sourceFile,fileReference);
};
TsInternal.convertToRelativePath = function(absoluteOrRelativePath,basePath,getCanonicalFileName) {
	return ts.convertToRelativePath(absoluteOrRelativePath,basePath,getCanonicalFileName);
};
TsInternal.getSourceFileLocals = function(sourceFile) {
	return Reflect.field(sourceFile,"locals");
};
TsInternal.getSourceFileModuleAugmentations = function(sourceFile) {
	return Reflect.field(sourceFile,"moduleAugmentations");
};
TsInternal.resolveExternalModuleSymbol = function(typeChecker,symbol) {
	return typeChecker.resolveExternalModuleSymbol(symbol);
};
TsInternal.getExpandedParameters = function(typeChecker,signature) {
	return typeChecker.getExpandedParameters(signature);
};
var ds_OnceOnlyQueue = function() {
	this.currentQueue = [];
	this.allItemsSeen = [];
};
ds_OnceOnlyQueue.__name__ = true;
ds_OnceOnlyQueue.prototype = {
	tryEnqueue: function(item) {
		if(this.allItemsSeen.indexOf(item) == -1) {
			this.allItemsSeen.push(item);
			this.currentQueue.push(item);
			return true;
		}
		return false;
	}
	,dequeue: function() {
		return this.currentQueue.shift();
	}
};
var ds_OnceOnlySymbolQueue = function() {
	this.currentQueue = [];
	this.allItemsSeen = new haxe_ds_IntMap();
};
ds_OnceOnlySymbolQueue.__name__ = true;
ds_OnceOnlySymbolQueue.prototype = {
	tryEnqueue: function(item) {
		var id = tool_TsSymbolTools.getId(item);
		if(!this.allItemsSeen.h.hasOwnProperty(id)) {
			this.allItemsSeen.h[id] = true;
			this.currentQueue.push(item);
			return true;
		}
		return false;
	}
	,dequeue: function() {
		return this.currentQueue.shift();
	}
	,empty: function() {
		return this.currentQueue.length == 0;
	}
};
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			str += ", " + Std.string(v1);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ds_ArraySort = function() { };
haxe_ds_ArraySort.__name__ = true;
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) (this.h.hasOwnProperty(key) ? a.push(key | 0) : null);
		return HxOverrides.iter(a);
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.prototype = {
	get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths1 = _g;
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g3 = 1;
	var _g11 = paths1.length;
	while(_g3 < _g11) {
		var i = _g3++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
haxe_iterators_MapKeyValueIterator.__name__ = true;
haxe_iterators_MapKeyValueIterator.prototype = {
	hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__ : true, __constructs__ : ["DoubleQuotes","SingleQuotes"]
	,DoubleQuotes: {_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
var haxe_macro_QuoteStatus = $hxEnums["haxe.macro.QuoteStatus"] = { __ename__ : true, __constructs__ : ["Unquoted","Quoted"]
	,Unquoted: {_hx_index:0,__enum__:"haxe.macro.QuoteStatus",toString:$estr}
	,Quoted: {_hx_index:1,__enum__:"haxe.macro.QuoteStatus",toString:$estr}
};
var haxe_macro_FunctionKind = $hxEnums["haxe.macro.FunctionKind"] = { __ename__ : true, __constructs__ : ["FAnonymous","FNamed","FArrow"]
	,FAnonymous: {_hx_index:0,__enum__:"haxe.macro.FunctionKind",toString:$estr}
	,FNamed: ($_=function(name,inlined) { return {_hx_index:1,name:name,inlined:inlined,__enum__:"haxe.macro.FunctionKind",toString:$estr}; },$_.__params__ = ["name","inlined"],$_)
	,FArrow: {_hx_index:2,__enum__:"haxe.macro.FunctionKind",toString:$estr}
};
var haxe_macro_ExprDef = $hxEnums["haxe.macro.ExprDef"] = { __ename__ : true, __constructs__ : ["EConst","EArray","EBinop","EField","EParenthesis","EObjectDecl","EArrayDecl","ECall","ENew","EUnop","EVars","EFunction","EBlock","EFor","EIf","EWhile","ESwitch","ETry","EReturn","EBreak","EContinue","EUntyped","EThrow","ECast","EDisplay","EDisplayNew","ETernary","ECheckType","EMeta"]
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,EArray: ($_=function(e1,e2) { return {_hx_index:1,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e1","e2"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:2,op:op,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","e1","e2"],$_)
	,EField: ($_=function(e,field) { return {_hx_index:3,e:e,field:field,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","field"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EObjectDecl: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,EArrayDecl: ($_=function(values) { return {_hx_index:6,values:values,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["values"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:7,e:e,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","params"],$_)
	,ENew: ($_=function(t,params) { return {_hx_index:8,t:t,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t","params"],$_)
	,EUnop: ($_=function(op,postFix,e) { return {_hx_index:9,op:op,postFix:postFix,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","postFix","e"],$_)
	,EVars: ($_=function(vars) { return {_hx_index:10,vars:vars,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["vars"],$_)
	,EFunction: ($_=function(kind,f) { return {_hx_index:11,kind:kind,f:f,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["kind","f"],$_)
	,EBlock: ($_=function(exprs) { return {_hx_index:12,exprs:exprs,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["exprs"],$_)
	,EFor: ($_=function(it,expr) { return {_hx_index:13,it:it,expr:expr,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["it","expr"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:14,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,EWhile: ($_=function(econd,e,normalWhile) { return {_hx_index:15,econd:econd,e:e,normalWhile:normalWhile,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","e","normalWhile"],$_)
	,ESwitch: ($_=function(e,cases,edef) { return {_hx_index:16,e:e,cases:cases,edef:edef,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","cases","edef"],$_)
	,ETry: ($_=function(e,catches) { return {_hx_index:17,e:e,catches:catches,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","catches"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:18,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EBreak: {_hx_index:19,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EContinue: {_hx_index:20,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EUntyped: ($_=function(e) { return {_hx_index:21,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:22,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,ECast: ($_=function(e,t) { return {_hx_index:23,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EDisplay: ($_=function(e,displayKind) { return {_hx_index:24,e:e,displayKind:displayKind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","displayKind"],$_)
	,EDisplayNew: ($_=function(t) { return {_hx_index:25,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t"],$_)
	,ETernary: ($_=function(econd,eif,eelse) { return {_hx_index:26,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:27,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EMeta: ($_=function(s,e) { return {_hx_index:28,s:s,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["s","e"],$_)
};
var haxe_macro_DisplayKind = $hxEnums["haxe.macro.DisplayKind"] = { __ename__ : true, __constructs__ : ["DKCall","DKDot","DKStructure","DKMarked","DKPattern"]
	,DKCall: {_hx_index:0,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKDot: {_hx_index:1,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKStructure: {_hx_index:2,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKMarked: {_hx_index:3,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKPattern: ($_=function(outermost) { return {_hx_index:4,outermost:outermost,__enum__:"haxe.macro.DisplayKind",toString:$estr}; },$_.__params__ = ["outermost"],$_)
};
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__ : true, __constructs__ : ["TPath","TFunction","TAnonymous","TParent","TExtend","TOptional","TNamed","TIntersection"]
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["tl"],$_)
};
var haxe_macro_TypeParam = $hxEnums["haxe.macro.TypeParam"] = { __ename__ : true, __constructs__ : ["TPType","TPExpr"]
	,TPType: ($_=function(t) { return {_hx_index:0,t:t,__enum__:"haxe.macro.TypeParam",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TPExpr: ($_=function(e) { return {_hx_index:1,e:e,__enum__:"haxe.macro.TypeParam",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_macro_Access = $hxEnums["haxe.macro.Access"] = { __ename__ : true, __constructs__ : ["APublic","APrivate","AStatic","AOverride","ADynamic","AInline","AMacro","AFinal","AExtern"]
	,APublic: {_hx_index:0,__enum__:"haxe.macro.Access",toString:$estr}
	,APrivate: {_hx_index:1,__enum__:"haxe.macro.Access",toString:$estr}
	,AStatic: {_hx_index:2,__enum__:"haxe.macro.Access",toString:$estr}
	,AOverride: {_hx_index:3,__enum__:"haxe.macro.Access",toString:$estr}
	,ADynamic: {_hx_index:4,__enum__:"haxe.macro.Access",toString:$estr}
	,AInline: {_hx_index:5,__enum__:"haxe.macro.Access",toString:$estr}
	,AMacro: {_hx_index:6,__enum__:"haxe.macro.Access",toString:$estr}
	,AFinal: {_hx_index:7,__enum__:"haxe.macro.Access",toString:$estr}
	,AExtern: {_hx_index:8,__enum__:"haxe.macro.Access",toString:$estr}
};
var haxe_macro_FieldType = $hxEnums["haxe.macro.FieldType"] = { __ename__ : true, __constructs__ : ["FVar","FFun","FProp"]
	,FVar: ($_=function(t,e) { return {_hx_index:0,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["t","e"],$_)
	,FFun: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["f"],$_)
	,FProp: ($_=function(get,set,t,e) { return {_hx_index:2,get:get,set:set,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["get","set","t","e"],$_)
};
var haxe_macro_TypeDefKind = $hxEnums["haxe.macro.TypeDefKind"] = { __ename__ : true, __constructs__ : ["TDEnum","TDStructure","TDClass","TDAlias","TDAbstract"]
	,TDEnum: {_hx_index:0,__enum__:"haxe.macro.TypeDefKind",toString:$estr}
	,TDStructure: {_hx_index:1,__enum__:"haxe.macro.TypeDefKind",toString:$estr}
	,TDClass: ($_=function(superClass,interfaces,isInterface,isFinal) { return {_hx_index:2,superClass:superClass,interfaces:interfaces,isInterface:isInterface,isFinal:isFinal,__enum__:"haxe.macro.TypeDefKind",toString:$estr}; },$_.__params__ = ["superClass","interfaces","isInterface","isFinal"],$_)
	,TDAlias: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.TypeDefKind",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TDAbstract: ($_=function(tthis,from,to) { return {_hx_index:4,tthis:tthis,from:from,to:to,__enum__:"haxe.macro.TypeDefKind",toString:$estr}; },$_.__params__ = ["tthis","from","to"],$_)
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if(((val) instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_buffer_Buffer = require("buffer").Buffer;
var tool_ComplexTypeTools = function() { };
tool_ComplexTypeTools.__name__ = true;
tool_ComplexTypeTools.map = function(complexType,f) {
	if(complexType == null) {
		return null;
	}
	switch(complexType._hx_index) {
	case 0:
		var p = complexType.p;
		return f(haxe_macro_ComplexType.TPath(tool_ComplexTypeTools.mapTypePath(p,f)));
	case 1:
		var ret = complexType.ret;
		var args = complexType.args;
		var result = new Array(args.length);
		var _g = 0;
		var _g1 = args.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = tool_ComplexTypeTools.map(args[i],f);
		}
		return f(haxe_macro_ComplexType.TFunction(result,tool_ComplexTypeTools.map(ret,f)));
	case 2:
		var fields = complexType.fields;
		var result1 = new Array(fields.length);
		var _g2 = 0;
		var _g11 = fields.length;
		while(_g2 < _g11) {
			var i1 = _g2++;
			result1[i1] = tool_ComplexTypeTools.mapField(fields[i1],f);
		}
		return f(haxe_macro_ComplexType.TAnonymous(result1));
	case 3:
		var t = complexType.t;
		return f(haxe_macro_ComplexType.TParent(tool_ComplexTypeTools.map(t,f)));
	case 4:
		var fields1 = complexType.fields;
		var ap = complexType.p;
		var result2 = new Array(ap.length);
		var _g3 = 0;
		var _g12 = ap.length;
		while(_g3 < _g12) {
			var i2 = _g3++;
			result2[i2] = tool_ComplexTypeTools.mapTypePath(ap[i2],f);
		}
		var tmp = result2;
		var result3 = new Array(fields1.length);
		var _g4 = 0;
		var _g13 = fields1.length;
		while(_g4 < _g13) {
			var i3 = _g4++;
			result3[i3] = tool_ComplexTypeTools.mapField(fields1[i3],f);
		}
		return f(haxe_macro_ComplexType.TExtend(tmp,result3));
	case 5:
		var t1 = complexType.t;
		return f(haxe_macro_ComplexType.TOptional(tool_ComplexTypeTools.map(t1,f)));
	case 6:
		var t2 = complexType.t;
		var n = complexType.n;
		return f(haxe_macro_ComplexType.TNamed(n,tool_ComplexTypeTools.map(t2,f)));
	case 7:
		var types = complexType.tl;
		var result4 = new Array(types.length);
		var _g5 = 0;
		var _g14 = types.length;
		while(_g5 < _g14) {
			var i4 = _g5++;
			result4[i4] = tool_ComplexTypeTools.map(types[i4],f);
		}
		return f(haxe_macro_ComplexType.TIntersection(result4));
	}
};
tool_ComplexTypeTools.mapTypePath = function(typePath,f) {
	var typePath1 = typePath.pack;
	var typePath2 = typePath.name;
	var typePath3 = typePath.sub;
	var tmp;
	if(typePath.params != null) {
		var _this = typePath.params;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var tp = _this[i];
			var tmp1;
			switch(tp._hx_index) {
			case 0:
				var t = tp.t;
				tmp1 = haxe_macro_TypeParam.TPType(tool_ComplexTypeTools.map(t,f));
				break;
			case 1:
				var e = tp.e;
				tmp1 = haxe_macro_TypeParam.TPExpr(e);
				break;
			}
			result[i] = tmp1;
		}
		tmp = result;
	} else {
		tmp = null;
	}
	return { pack : typePath1, name : typePath2, sub : typePath3, params : tmp};
};
tool_ComplexTypeTools.mapArg = function(arg,f) {
	return { name : arg.name, meta : arg.meta, value : arg.value, opt : arg.opt, type : tool_ComplexTypeTools.map(arg.type,f)};
};
tool_ComplexTypeTools.mapFunction = function(fun,f) {
	var fun1 = fun.params;
	var fun2 = fun.expr;
	var _this = fun.args;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = tool_ComplexTypeTools.mapArg(_this[i],f);
	}
	return { params : fun1, expr : fun2, args : result, ret : tool_ComplexTypeTools.map(fun.ret,f)};
};
tool_ComplexTypeTools.mapField = function(field,f) {
	var field1 = field.name;
	var field2 = field.meta;
	var field3 = field.pos;
	var field4 = field.access;
	var field5 = field.doc;
	var _g = field.kind;
	var tmp;
	switch(_g._hx_index) {
	case 0:
		var e = _g.e;
		var t = _g.t;
		tmp = haxe_macro_FieldType.FVar(tool_ComplexTypeTools.map(t,f),e);
		break;
	case 1:
		var fun = _g.f;
		tmp = haxe_macro_FieldType.FFun(tool_ComplexTypeTools.mapFunction(fun,f));
		break;
	case 2:
		var e1 = _g.e;
		var t1 = _g.t;
		var set = _g.set;
		var get = _g.get;
		tmp = haxe_macro_FieldType.FProp(get,set,tool_ComplexTypeTools.map(t1,f),e1);
		break;
	}
	return { name : field1, meta : field2, pos : field3, access : field4, doc : field5, kind : tmp};
};
var tool_HaxeTools = function() { };
tool_HaxeTools.__name__ = true;
tool_HaxeTools.setMeta = function(field,metaName,params) {
	var metas = field.meta;
	if(metas == null) {
		metas = [];
		field.meta = metas;
	}
	var existingMeta = Lambda.find(metas,function(m) {
		return m.name == metaName;
	});
	if(existingMeta != null) {
		existingMeta.params = params;
	} else {
		metas.push({ name : metaName, params : params, pos : null});
	}
};
tool_HaxeTools.getNativeName = function(field) {
	var nativeMeta = tool_HaxeTools.getMeta(field,":native");
	var _g = nativeMeta;
	if(_g != null) {
		var _g3 = _g.pos;
		var _g2 = _g.params;
		var _g1 = _g.name;
		if(_g2 != null) {
			if(_g2.length == 1) {
				var _g4 = _g2[0];
				var _g6 = _g4.pos;
				var _g5 = _g4.expr;
				if(_g5._hx_index == 0) {
					var _g7 = _g5.c;
					if(_g7._hx_index == 2) {
						var _g9 = _g7.kind;
						var s = _g7.s;
						return s;
					}
				}
			}
		}
	}
	return field.name;
};
tool_HaxeTools.getMeta = function(field,metaName) {
	if(field.meta != null) {
		return Lambda.find(field.meta,function(m) {
			return m.name == metaName;
		});
	} else {
		return null;
	}
};
tool_HaxeTools.hasAccess = function(field,access) {
	if(field.access != null) {
		return Lambda.has(field.access,access);
	} else {
		return false;
	}
};
tool_HaxeTools.enableAccess = function(field,access) {
	var accessArray = field.access != null ? field.access : field.access = [];
	if(accessArray.indexOf(access) == -1) {
		accessArray.push(access);
	}
};
tool_HaxeTools.disableAccess = function(field,access) {
	if(field.access != null) {
		var _g = [];
		var _g1 = 0;
		var _g2 = field.access;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != access) {
				_g.push(v);
			}
		}
		field.access = _g;
	}
};
tool_HaxeTools.resolveNameCollisions = function(fields) {
	var renameability = function(field) {
		var renameability1 = tool_HaxeTools.getMeta(field,":native") != null ? 1 : 0;
		var renameability2 = tool_HaxeTools.hasAccess(field,haxe_macro_Access.AStatic) ? 1 : 0;
		var _g = field.kind;
		var renameability3;
		if(_g._hx_index == 0) {
			var _g2 = _g.e;
			var _g1 = _g.t;
			renameability3 = true;
		} else {
			renameability3 = false;
		}
		return renameability1 << 2 | renameability2 << 1 | (renameability3 ? 1 : 0);
	};
	while(true) {
		var nameMap = new haxe_ds_StringMap();
		var _g3 = 0;
		while(_g3 < fields.length) {
			var field1 = fields[_g3];
			++_g3;
			var key = field1.name;
			var array = __map_reserved[key] != null ? nameMap.getReserved(key) : nameMap.h[key];
			if(array == null) {
				array = [];
				var key1 = field1.name;
				if(__map_reserved[key1] != null) {
					nameMap.setReserved(key1,array);
				} else {
					nameMap.h[key1] = array;
				}
			}
			array.push(field1);
		}
		var noNamesOverlap = true;
		var _g11 = new haxe_iterators_MapKeyValueIterator(nameMap);
		while(_g11.hasNext()) {
			var _g21 = _g11.next();
			var _ = _g21.key;
			var collidingFields = _g21.value;
			if(collidingFields.length > 1) {
				noNamesOverlap = false;
				haxe_ds_ArraySort.sort(collidingFields,function(a,b) {
					return renameability(b) - renameability(a);
				});
				var fieldToRename = collidingFields[0];
				if(tool_HaxeTools.getMeta(fieldToRename,":native") == null && tool_HaxeTools.getMeta(fieldToRename,":selfCall") == null) {
					tool_HaxeTools.setMeta(fieldToRename,":native",[tool_HaxeTools.toStringExpr(fieldToRename.name)]);
				}
				fieldToRename.name += "_";
			}
		}
		if(noNamesOverlap) {
			break;
		}
	}
};
tool_HaxeTools.toSafeIdent = function(str,escapeReservedWords) {
	if(escapeReservedWords == null) {
		escapeReservedWords = true;
	}
	var _this_r = new RegExp("[\"'`]","gm".split("u").join(""));
	str = str.replace(_this_r,"");
	var _this_r1 = new RegExp("^@","".split("u").join(""));
	str = str.replace(_this_r1,"");
	var _this_r2 = new RegExp("[-–—.]","gm".split("u").join(""));
	str = str.replace(_this_r2,"_");
	var _this_r3 = new RegExp("[/\\\\]","gm".split("u").join(""));
	str = str.replace(_this_r3,"_");
	str = new EReg("([^0-9a-z_]|^[^a-z_]+)([a-z])?","ig").map(str,function(reg) {
		var illegalChars = reg.matched(1);
		var followingChar = reg.matched(2);
		var _this = illegalChars.split("");
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var char = _this[i];
			var _this1 = tool_HaxeTools.specialCharacterNames;
			var charName = __map_reserved[char] != null ? _this1.getReserved(char) : _this1.h[char];
			result[i] = charName != null ? charName : "_";
		}
		return result.join("") + (followingChar != null ? followingChar.toUpperCase() : "");
	});
	if(escapeReservedWords && tool_HaxeTools.haxeReservedWords.indexOf(str) != -1) {
		str += "_";
	}
	return str;
};
tool_HaxeTools.toSafeTypeName = function(str) {
	str = tool_HaxeTools.toSafeIdent(str,false);
	return str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
};
tool_HaxeTools.toSafePackageName = function(str) {
	return tool_HaxeTools.toSafeIdent(str,true).toLowerCase();
};
tool_HaxeTools.toStringExpr = function(str,pos) {
	return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(str,haxe_macro_StringLiteralKind.DoubleQuotes)), pos : pos != null ? pos : tool_HaxeTools.nullPosition};
};
tool_HaxeTools.toIntExpr = function(int,pos) {
	return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(int == null ? "null" : "" + int)), pos : pos != null ? pos : tool_HaxeTools.nullPosition};
};
tool_HaxeTools.primitiveValueToExpr = function(value) {
	if(value == null) {
		return null;
	}
	switch(typeof(value)) {
	case "boolean":
		return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(value == true ? "true" : "false")), pos : tool_HaxeTools.nullPosition};
	case "number":
		return { expr : haxe_macro_ExprDef.EConst(Math.floor(value) == value ? haxe_macro_Constant.CInt(Std.string(value)) : haxe_macro_Constant.CFloat(Std.string(value))), pos : tool_HaxeTools.nullPosition};
	case "string":
		return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(value,haxe_macro_StringLiteralKind.DoubleQuotes)), pos : tool_HaxeTools.nullPosition};
	default:
		return null;
	}
};
tool_HaxeTools.deduplicateTypes = function(types) {
	var typeStringMap = new haxe_ds_StringMap();
	var printer = new haxe_macro_Printer();
	var _g = 0;
	while(_g < types.length) {
		var type = types[_g];
		++_g;
		var typeString = printer.printComplexType(type);
		if(__map_reserved[typeString] != null) {
			typeStringMap.setReserved(typeString,type);
		} else {
			typeStringMap.h[typeString] = type;
		}
	}
	var _g1 = [];
	var _g2 = new haxe_iterators_MapKeyValueIterator(typeStringMap);
	while(_g2.hasNext()) {
		var _g3 = _g2.next();
		var _ = _g3.key;
		var type1 = _g3.value;
		_g1.push(type1);
	}
	return _g1;
};
tool_HaxeTools.unwrapNull = function(type) {
	if(type._hx_index == 0) {
		var _g = type.p;
		var _g4 = _g.sub;
		var _g3 = _g.params;
		var _g2 = _g.pack;
		if(_g.name == "Null") {
			switch(_g2.length) {
			case 0:
				if(_g3 == null) {
					return type;
				} else if(_g3.length == 1) {
					var _g8 = _g3[0];
					if(_g8._hx_index == 0) {
						var innerType = _g8.t;
						return innerType;
					} else {
						return type;
					}
				} else {
					return type;
				}
				break;
			case 1:
				if(_g2[0] == "std") {
					if(_g3 == null) {
						return type;
					} else if(_g3.length == 1) {
						var _g6 = _g3[0];
						if(_g6._hx_index == 0) {
							var innerType1 = _g6.t;
							return innerType1;
						} else {
							return type;
						}
					} else {
						return type;
					}
				} else {
					return type;
				}
				break;
			default:
				return type;
			}
		} else {
			return type;
		}
	} else {
		return type;
	}
};
var tool_StringTools = function() { };
tool_StringTools.__name__ = true;
tool_StringTools.unwrapQuotes = function(str) {
	var _g = str.charAt(0);
	switch(_g) {
	case "\"":case "'":case "`":
		var q = _g;
		if(str.charAt(str.length - 1) == q) {
			return HxOverrides.substr(str,1,str.length - 2);
		} else {
			return str;
		}
		break;
	default:
		return str;
	}
};
tool_StringTools.removeIndentation = function(str) {
	var lines = str.split("\n");
	var commonTabsCount = null;
	var commonSpaceCount = null;
	var spacePrefixPattern = new EReg("^([ \t]*)[^\\s]","");
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		if(spacePrefixPattern.match(line)) {
			var space = spacePrefixPattern.matched(1);
			var tabsCount = 0;
			var spaceCount = 0;
			var _g1 = 0;
			var _g11 = space.length;
			while(_g1 < _g11) {
				var i = _g1++;
				if(space.charAt(i) == "\t") {
					++tabsCount;
				}
				if(space.charAt(i) == " ") {
					++spaceCount;
				}
			}
			commonTabsCount = commonTabsCount != null ? Math.min(commonTabsCount,tabsCount) | 0 : tabsCount;
			commonSpaceCount = commonSpaceCount != null ? Math.min(commonSpaceCount,spaceCount) | 0 : spaceCount;
		}
	}
	var spaceCharCount = commonTabsCount + commonSpaceCount;
	if(spaceCharCount > 0) {
		var result = new Array(lines.length);
		var _g2 = 0;
		var _g12 = lines.length;
		while(_g2 < _g12) {
			var i1 = _g2++;
			var line1 = lines[i1];
			result[i1] = spacePrefixPattern.match(line1) ? HxOverrides.substr(line1,spaceCharCount,null) : line1;
		}
		return result.join("\n");
	} else {
		return str;
	}
};
var tool_SymbolAccessTools = function() { };
tool_SymbolAccessTools.__name__ = true;
tool_SymbolAccessTools.extractSymbolChain = function(access) {
	switch(access._hx_index) {
	case 0:
		var _g1 = access.moduleSymbol;
		var _g = access.modulePath;
		var symbolChain = access.symbolChain;
		return symbolChain;
	case 1:
		var _g5 = access.sourceFileSymbol;
		var _g4 = access.moduleName;
		var symbolChain1 = access.symbolChain;
		return symbolChain1;
	case 2:
		var symbolChain2 = access.symbolChain;
		return symbolChain2;
	case 3:
		return [];
	}
};
tool_SymbolAccessTools.getIdentifierChain = function(access) {
	var _this = tool_SymbolAccessTools.extractSymbolChain(access);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = _this[i].name;
	}
	return result;
};
tool_SymbolAccessTools.toAccessMetadata = function(access) {
	var pos = tool_SymbolAccessTools.getPosition(access);
	var identifierChain = tool_SymbolAccessTools.getIdentifierChain(access);
	switch(access._hx_index) {
	case 0:
		var _g2 = access.symbolChain;
		var _g1 = access.moduleSymbol;
		var path = access.modulePath;
		return { name : ":jsRequire", params : [tool_HaxeTools.toStringExpr(tool_StringTools.unwrapQuotes(path),pos)].concat(identifierChain.length > 0 ? [tool_HaxeTools.toStringExpr(identifierChain.join("."),pos)] : []), pos : pos};
	case 1:
		var _g6 = access.symbolChain;
		var _g5 = access.sourceFileSymbol;
		var path1 = access.moduleName;
		return { name : ":jsRequire", params : [tool_HaxeTools.toStringExpr(tool_StringTools.unwrapQuotes(path1),pos)].concat(identifierChain.length > 0 ? [tool_HaxeTools.toStringExpr(identifierChain.join("."),pos)] : []), pos : pos};
	case 2:
		var _g3 = access.symbolChain;
		return { name : ":native", params : [tool_HaxeTools.toStringExpr(identifierChain.join("."),pos)], pos : pos};
	case 3:
		return { name : "jsInaccessible", pos : pos};
	}
};
tool_SymbolAccessTools.getPosition = function(access) {
	return null;
};
tool_SymbolAccessTools.toString = function(access) {
	var identifierChain = tool_SymbolAccessTools.getIdentifierChain(access);
	switch(access._hx_index) {
	case 0:
		var _g2 = access.symbolChain;
		var _g1 = access.moduleSymbol;
		var path = access.modulePath;
		return ["ambientRequire(" + path + ")"].concat(identifierChain).join(".");
	case 1:
		var _g6 = access.symbolChain;
		var _g5 = access.sourceFileSymbol;
		var moduleName = access.moduleName;
		return ["exportRequire(\"" + moduleName + "\")"].concat(identifierChain).join(".");
	case 2:
		var _g3 = access.symbolChain;
		return "::" + identifierChain.join(".");
	case 3:
		return "*Inaccessible*";
	}
};
var tool_TsProgramTools = function() { };
tool_TsProgramTools.__name__ = true;
tool_TsProgramTools.getAllDiagnostics = function(program) {
	return program.getGlobalDiagnostics().concat(program.getOptionsDiagnostics()).concat(program.getSemanticDiagnostics()).concat(program.getSyntacticDiagnostics()).concat(program.getDeclarationDiagnostics()).concat(program.getConfigFileParsingDiagnostics());
};
tool_TsProgramTools.resolveAllTypeReferenceDirectives = function(program,host) {
	var _g = [];
	var _g1 = 0;
	var _g2 = program.getSourceFiles();
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(!program.isSourceFileDefaultLibrary(v)) {
			_g.push(v);
		}
	}
	var sourceFiles = _g;
	var typeReferences = [];
	var _g3 = 0;
	while(_g3 < sourceFiles.length) {
		var s = sourceFiles[_g3];
		++_g3;
		var _g4 = 0;
		var _g11 = s.typeReferenceDirectives;
		while(_g4 < _g11.length) {
			var t = _g11[_g4];
			++_g4;
			var resolved = ts.resolveTypeReferenceDirective(t.fileName,s.fileName,program.getCompilerOptions(),host);
			typeReferences.push(resolved);
		}
	}
	return typeReferences;
};
tool_TsProgramTools.getGlobalScopeSymbolsInSourceFile = function(program,sourceFile) {
	var tc = program.getTypeChecker();
	var sourceFileSymbol = tc.getSymbolAtLocation(sourceFile);
	var globalSymbols = [];
	if(sourceFileSymbol == null) {
		var locals = TsInternal.getSourceFileLocals(sourceFile);
		locals.forEach(function(localSymbol,key,_) {
			var tmp = tc.getExportSymbolOfSymbol(localSymbol);
			return globalSymbols.push(tmp);
		});
	}
	var moduleAugmentations = TsInternal.getSourceFileModuleAugmentations(sourceFile);
	var globalAugmentations = [];
	var _g = 0;
	while(_g < moduleAugmentations.length) {
		var moduleAugmentation = moduleAugmentations[_g];
		++_g;
		if(ts.isIdentifier(moduleAugmentation)) {
			var ident = moduleAugmentation;
			var identSymbol = tc.getSymbolAtLocation(ident);
			if(identSymbol != null && identSymbol.escapedName == ts.InternalSymbolName.Global) {
				globalAugmentations.push(identSymbol);
			}
		}
	}
	var _g1 = 0;
	while(_g1 < globalAugmentations.length) {
		var g = globalAugmentations[_g1];
		++_g1;
		var _g11 = 0;
		var _g2 = tc.getExportsOfModule(g);
		while(_g11 < _g2.length) {
			var s = _g2[_g11];
			++_g11;
			var tmp1 = tc.getExportSymbolOfSymbol(s);
			globalSymbols.push(tmp1);
		}
	}
	return globalSymbols;
};
tool_TsProgramTools.getExposedSymbolsOfSourceFile = function(program,sourceFile) {
	var tc = program.getTypeChecker();
	var globalScopeSymbols = tool_TsProgramTools.getGlobalScopeSymbolsInSourceFile(program,sourceFile);
	var sourceFileSymbol = tc.getSymbolAtLocation(sourceFile);
	if(sourceFileSymbol != null) {
		return [sourceFileSymbol].concat(globalScopeSymbols);
	} else {
		return globalScopeSymbols;
	}
};
tool_TsProgramTools.getTopLevelDeclarationSymbols = function(program) {
	var tc = program.getTypeChecker();
	var seenSymbols_h = { };
	var result = [];
	var _g = 0;
	var _g1 = program.getSourceFiles();
	while(_g < _g1.length) {
		var sourceFile = _g1[_g];
		++_g;
		var sourceFileSymbol = tc.getSymbolAtLocation(sourceFile);
		if(sourceFileSymbol != null) {
			var symbol = sourceFileSymbol;
			symbol = tc.getExportSymbolOfSymbol(symbol);
			var key = tool_TsSymbolTools.getId(symbol);
			if(!seenSymbols_h.hasOwnProperty(key)) {
				seenSymbols_h[tool_TsSymbolTools.getId(symbol)] = symbol;
				result.push(symbol);
			}
		}
		var _g2 = 0;
		var _g11 = tc.getSymbolsInScope(sourceFile,16777215);
		while(_g2 < _g11.length) {
			var symbol1 = _g11[_g2];
			++_g2;
			var symbol2 = symbol1;
			symbol2 = tc.getExportSymbolOfSymbol(symbol2);
			var key1 = tool_TsSymbolTools.getId(symbol2);
			if(!seenSymbols_h.hasOwnProperty(key1)) {
				seenSymbols_h[tool_TsSymbolTools.getId(symbol2)] = symbol2;
				result.push(symbol2);
			}
		}
	}
	return result;
};
tool_TsProgramTools.walkReferencedSourceFiles = function(program,sourceFile,onSourceFile) {
	onSourceFile(sourceFile);
	var _g = 0;
	var _g1 = sourceFile.referencedFiles;
	while(_g < _g1.length) {
		var fileRef = _g1[_g];
		++_g;
		var referenceSourceFile = TsInternal.getSourceFileFromReference(program,sourceFile,fileRef);
		if(referenceSourceFile != null) {
			tool_TsProgramTools.walkReferencedSourceFiles(program,referenceSourceFile,onSourceFile);
		}
	}
};
tool_TsProgramTools.isDirectPathReferenceModule = function(moduleName) {
	var c0 = moduleName.charAt(0);
	if(c0 != ".") {
		return c0 == "/";
	} else {
		return true;
	}
};
var tool_TsSymbolTools = function() { };
tool_TsSymbolTools.__name__ = true;
tool_TsSymbolTools.getId = function(symbol) {
	return ts.getSymbolId(symbol) | 0;
};
tool_TsSymbolTools.isAccessibleField = function(symbol) {
	var isKnownSymbol = StringTools.startsWith(symbol.escapedName,"__@");
	var FieldSymbolFlags = ts.SymbolFlags.Variable | ts.SymbolFlags.Function | ts.SymbolFlags.ClassMember;
	if(symbol.name == "__promisify__") {
		return false;
	}
	if(!isKnownSymbol && (symbol.flags & FieldSymbolFlags) != 0) {
		return (symbol.flags & ts.SymbolFlags.Prototype) == 0;
	} else {
		return false;
	}
};
tool_TsSymbolTools.isExternalModuleSymbol = function(symbol) {
	if((symbol.flags & ts.SymbolFlags.Module) != 0) {
		return HxOverrides.cca(symbol.name,0) == 34;
	} else {
		return false;
	}
};
tool_TsSymbolTools.isSourceFileSymbol = function(symbol) {
	if((symbol.flags & ts.SymbolFlags.Module) != 0 && symbol.valueDeclaration != null) {
		return ts.isSourceFile(symbol.valueDeclaration);
	} else {
		return false;
	}
};
tool_TsSymbolTools.isConstructorTypeVariableSymbol = function(tc,symbol) {
	if((symbol.flags & ts.SymbolFlags.Variable) != 0 && symbol.valueDeclaration != null) {
		var varType = tc.getTypeOfSymbolAtLocation(symbol,symbol.valueDeclaration);
		return tool_TsTypeTools.isConstructorType(tc,varType);
	} else {
		return false;
	}
};
tool_TsSymbolTools.getSymbolParents = function(symbol) {
	var parentChain = [];
	var currentSymbol = symbol;
	while(currentSymbol != null) {
		currentSymbol = tool_TsSymbolTools.getSymbolParent(currentSymbol);
		if(currentSymbol != null) {
			parentChain.unshift(currentSymbol);
		}
	}
	return parentChain;
};
tool_TsSymbolTools.getSymbolParent = function(symbol) {
	return Reflect.field(symbol,"parent");
};
tool_TsSymbolTools.getFlagsInfo = function(symbol,compositeFlags) {
	if(compositeFlags == null) {
		compositeFlags = false;
	}
	var activeFlags = [];
	var symbolFlagsEnum = tool_TsSymbolTools.getSymbolFlagsMap();
	var _g = new haxe_iterators_MapKeyValueIterator(symbolFlagsEnum);
	while(_g.hasNext()) {
		var _g1 = _g.next();
		var key = _g1.key;
		var value = _g1.value;
		if(!compositeFlags && (value & value - 1) != 0) {
			continue;
		}
		if((symbol.flags & value) != 0) {
			activeFlags.push(key);
		}
	}
	return activeFlags;
};
tool_TsSymbolTools.getPosition = function(symbol) {
	var node = symbol.valueDeclaration != null ? symbol.valueDeclaration : tool_TsSymbolTools.getDeclarationsArray(symbol)[0];
	if(node != null) {
		return { file : node.getSourceFile().fileName, min : node.getStart() | 0, max : node.getEnd() | 0};
	} else {
		return { file : "<unknown location>", min : -1, max : -1};
	}
};
tool_TsSymbolTools.getExports = function(symbol) {
	var exports = [];
	if(symbol.exports != null) {
		symbol.exports.forEach(function(s,_) {
			return exports.push(s);
		});
	}
	return exports;
};
tool_TsSymbolTools.getMembers = function(symbol) {
	var members = [];
	if(symbol.members != null) {
		symbol.members.forEach(function(s,_) {
			return members.push(s);
		});
	}
	return members;
};
tool_TsSymbolTools.getClassExtendsType = function(tc,symbol) {
	var classDeclaration = symbol.valueDeclaration != null && ts.isClassDeclaration(symbol.valueDeclaration) ? symbol.valueDeclaration : null;
	if(classDeclaration != null && classDeclaration.heritageClauses != null) {
		var extendsClause = Lambda.find(classDeclaration.heritageClauses,function(h) {
			return h.token == ts.SyntaxKind.ExtendsKeyword;
		});
		if(extendsClause != null) {
			var superTypeNode = extendsClause.types[0];
			var superType = tc.getTypeFromTypeNode(superTypeNode);
			return superType;
		}
	}
	return null;
};
tool_TsSymbolTools.getDeclarationsArray = function(symbol) {
	if(symbol.declarations != null) {
		return symbol.declarations;
	} else {
		return [];
	}
};
tool_TsSymbolTools.walkDeclarationSymbols = function(tc,symbol,onSymbol,accessChain,depth) {
	if(depth == null) {
		depth = 0;
	}
	accessChain = accessChain != null ? accessChain : [symbol];
	var _g = 0;
	var _g1 = accessChain.length - 1;
	while(_g < _g1) {
		var i = _g++;
		if(accessChain[i] == symbol) {
			return;
		}
	}
	var ignoredSymbolFlags = ts.SymbolFlags.ExportStar;
	if((symbol.flags & ts.SymbolFlags.Module) != 0) {
		var resolvedSymbol = TsInternal.resolveExternalModuleSymbol(tc,symbol);
		if(resolvedSymbol != symbol) {
			tool_TsSymbolTools.walkDeclarationSymbols(tc,resolvedSymbol,onSymbol,accessChain,depth);
			return;
		}
	}
	var handled = (symbol.flags & ignoredSymbolFlags) != 0;
	if((symbol.flags & ts.SymbolFlags.Alias) != 0) {
		handled = true;
		onSymbol(symbol,accessChain);
		var aliasedSymbol = tc.getAliasedSymbol(symbol);
		tool_TsSymbolTools.walkDeclarationSymbols(tc,aliasedSymbol,onSymbol,accessChain.concat([aliasedSymbol]),depth + 1);
	}
	if((symbol.flags & (ts.SymbolFlags.Type | ts.SymbolFlags.Variable | ts.SymbolFlags.Function | ts.SymbolFlags.Property)) != 0) {
		handled = true;
		onSymbol(symbol,accessChain);
	}
	if((symbol.flags & ts.SymbolFlags.Module) != 0) {
		handled = true;
		onSymbol(symbol,accessChain);
		var _g2 = [];
		var _g11 = 0;
		var _g21 = tc.getExportsOfModule(symbol);
		while(_g11 < _g21.length) {
			var v = _g21[_g11];
			++_g11;
			if((v.flags & ts.SymbolFlags.ModuleMember) != 0) {
				_g2.push(v);
			}
		}
		var moduleMembers = _g2;
		var _g22 = 0;
		while(_g22 < moduleMembers.length) {
			var moduleExport = moduleMembers[_g22];
			++_g22;
			tool_TsSymbolTools.walkDeclarationSymbols(tc,moduleExport,onSymbol,accessChain.concat([moduleExport]),depth + 1);
		}
	}
	if(!handled) {
		Log.warn("Symbol was not handled in <b>walkDeclarationSymbols()</>",null,symbol);
	}
};
tool_TsSymbolTools.getConstructorSignatures = function(symbol,tc) {
	var _g = [];
	var _g1 = 0;
	var _g2 = tool_TsSymbolTools.getMembers(symbol);
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if((v.flags & ts.SymbolFlags.Constructor) != 0 && v.escapedName == ts.InternalSymbolName.Constructor) {
			_g.push(v);
		}
	}
	var symbols = _g;
	var result = new Array(symbols.length);
	var _g3 = 0;
	var _g11 = symbols.length;
	while(_g3 < _g11) {
		var i = _g3++;
		var _g4 = [];
		var _g12 = 0;
		var _g21 = tool_TsSymbolTools.getDeclarationsArray(symbols[i]);
		while(_g12 < _g21.length) {
			var v1 = _g21[_g12];
			++_g12;
			if(ts.isConstructorDeclaration(v1)) {
				_g4.push(v1);
			}
		}
		result[i] = _g4;
	}
	var _g5 = [];
	var e = $getIterator(result);
	while(e.hasNext()) {
		var e1 = e.next();
		var x = $getIterator(e1);
		while(x.hasNext()) {
			var x1 = x.next();
			_g5.push(x1);
		}
	}
	var declarations = _g5;
	var result1 = new Array(declarations.length);
	var _g6 = 0;
	var _g13 = declarations.length;
	while(_g6 < _g13) {
		var i1 = _g6++;
		result1[i1] = tc.getSignatureFromDeclaration(declarations[i1]);
	}
	var signatures = result1;
	var _g7 = [];
	var _g14 = 0;
	var _g22 = signatures;
	while(_g14 < _g22.length) {
		var v2 = _g22[_g14];
		++_g14;
		if(v2 != null) {
			_g7.push(v2);
		}
	}
	return _g7;
};
tool_TsSymbolTools.isInternalSymbolName = function(name) {
	var internalSymbolName = require("typescript").InternalSymbolName;
	var internalSymbolNames = Object.values(internalSymbolName);
	return internalSymbolNames.indexOf(name) != -1;
};
tool_TsSymbolTools.getSymbolFlagsMap = function() {
	if(tool_TsSymbolTools._symbolFlagsMap == null) {
		tool_TsSymbolTools._symbolFlagsMap = new haxe_ds_StringMap();
		var _g = [];
		var _g1 = 0;
		var _g2 = Object.keys(require("typescript").SymbolFlags);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(new EReg("[a-z_]","i").match(v)) {
				_g.push(v);
			}
		}
		var symbolFlagsStringKeys = _g;
		var _g3 = 0;
		while(_g3 < symbolFlagsStringKeys.length) {
			var key = symbolFlagsStringKeys[_g3];
			++_g3;
			var value = require("typescript").SymbolFlags[key];
			var _this = tool_TsSymbolTools._symbolFlagsMap;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
	}
	return tool_TsSymbolTools._symbolFlagsMap;
};
var tool_TsSyntaxTools = function() { };
tool_TsSyntaxTools.__name__ = true;
tool_TsSyntaxTools.getSyntaxKindName = function(kind) {
	return require("typescript").SyntaxKind[kind];
};
tool_TsSyntaxTools.typeParameterDeclarationName = function(typeParameterDeclaration) {
	var name = typeParameterDeclaration.name;
	return tool_HaxeTools.toSafeTypeName(name.escapedText);
};
var tool_TsTypeTools = function() { };
tool_TsTypeTools.__name__ = true;
tool_TsTypeTools.getFlagsInfo = function(type,compositeFlags) {
	if(compositeFlags == null) {
		compositeFlags = false;
	}
	var activeFlags = [];
	var _g = new haxe_iterators_MapKeyValueIterator(tool_TsTypeTools.getTypeFlagsMap());
	while(_g.hasNext()) {
		var _g1 = _g.next();
		var key = _g1.key;
		var value = _g1.value;
		if(!compositeFlags && (value & value - 1) != 0) {
			continue;
		}
		if((type.flags & value) != 0) {
			activeFlags.push(key);
		}
	}
	return activeFlags;
};
tool_TsTypeTools.getObjectFlagsInfo = function(type,compositeFlags) {
	if(compositeFlags == null) {
		compositeFlags = false;
	}
	var activeFlags = [];
	var _g = new haxe_iterators_MapKeyValueIterator(tool_TsTypeTools.getObjectFlagsMap());
	while(_g.hasNext()) {
		var _g1 = _g.next();
		var key = _g1.key;
		var value = _g1.value;
		if(!compositeFlags && (value & value - 1) != 0) {
			continue;
		}
		if((type.objectFlags & value) != 0) {
			activeFlags.push(key);
		}
	}
	return activeFlags;
};
tool_TsTypeTools.isThisType = function(type) {
	return !(!type.isThisType);
};
tool_TsTypeTools.getThisTypeTarget = function(type) {
	return type.constraint;
};
tool_TsTypeTools.isConstructorType = function(tc,type) {
	return tc.getSignaturesOfType(type,ts.SignatureKind.Construct).length > 0;
};
tool_TsTypeTools.getIndexSignaturesOfType = function(tc,type) {
	var indexDeclarations = [];
	var numberInfo = tc.getIndexInfoOfType(type,ts.IndexKind.Number);
	var stringInfo = tc.getIndexInfoOfType(type,ts.IndexKind.String);
	if(numberInfo != null && numberInfo.declaration != null) {
		indexDeclarations.push(numberInfo.declaration);
	}
	if(stringInfo != null && stringInfo.declaration != null) {
		indexDeclarations.push(stringInfo.declaration);
	}
	var result = new Array(indexDeclarations.length);
	var _g = 0;
	var _g1 = indexDeclarations.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = tc.getSignatureFromDeclaration(indexDeclarations[i]);
	}
	return result;
};
tool_TsTypeTools.getTypeFlagsMap = function() {
	if(tool_TsTypeTools._typeFlagsMap == null) {
		tool_TsTypeTools._typeFlagsMap = new haxe_ds_StringMap();
		var _g = [];
		var _g1 = 0;
		var _g2 = Object.keys(require("typescript").TypeFlags);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(new EReg("[a-z_]","i").match(v)) {
				_g.push(v);
			}
		}
		var typeFlagsStringKeys = _g;
		var _g3 = 0;
		while(_g3 < typeFlagsStringKeys.length) {
			var key = typeFlagsStringKeys[_g3];
			++_g3;
			var value = require("typescript").TypeFlags[key];
			var _this = tool_TsTypeTools._typeFlagsMap;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
	}
	return tool_TsTypeTools._typeFlagsMap;
};
tool_TsTypeTools.getObjectFlagsMap = function() {
	if(tool_TsTypeTools._objectFlagsMap == null) {
		tool_TsTypeTools._objectFlagsMap = new haxe_ds_StringMap();
		var _g = [];
		var _g1 = 0;
		var _g2 = Object.keys(require("typescript").ObjectFlags);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(new EReg("[a-z_]","i").match(v)) {
				_g.push(v);
			}
		}
		var objectFlagsStringKeys = _g;
		var _g3 = 0;
		while(_g3 < objectFlagsStringKeys.length) {
			var key = objectFlagsStringKeys[_g3];
			++_g3;
			var value = require("typescript").ObjectFlags[key];
			var _this = tool_TsTypeTools._objectFlagsMap;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
	}
	return tool_TsTypeTools._objectFlagsMap;
};
var ts = require("typescript");
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.warnPrefix = "<b,yellow>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.unicodeCompatibilityMode = Sys.systemName() == "Windows" ? 1 : 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("(\\\\)?<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
ConverterContext.defaultNodeBuilderFlags = ts.NodeBuilderFlags.NoTruncation | ts.NodeBuilderFlags.WriteArrayAsGenericType;
ConverterContext.selfCallFunctionName = "call";
Log.logs = [];
Log.warnings = [];
Log.errors = [];
Log.printLogs = true;
Log.printWarnings = true;
Log.printErrors = true;
Main.dts2hxPackageJson = { keywords : ["haxe","typescript","externs","dts2hx","type definitions","types","cross-platform"], main : "dist/dts2hx.js", name : "dts2hx", description : "Converts TypeScript definition files (d.ts) to haxe externs", repository : { url : "https://github.com/haxiomic/dts2hx", type : "git"}, dependencies : { typescript : "3.7.4"}, devDependencies : { "@types/node" : "11.11.3"}, version : "0.5.2", author : "haxiomic", scripts : { prepare : "haxe build.hxml"}, license : "ISC", bin : "./cli.js"};
tool_HaxeTools.nullPosition = { file : "", min : -1, max : -1};
tool_HaxeTools.haxeReservedWords = ["public","private","static","override","dynamic","inline","macro","final","extern","function","class","static","var","if","else","while","do","for","break","return","continue","extends","implements","import","switch","case","default","private","public","try","catch","new","this","throw","extern","enum","in","interface","untyped","cast","override","typedef","dynamic","package","inline","using","null","true","false","abstract","macro","final","operator","overload","protected"];
tool_HaxeTools.specialCharacterNames = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["0"] != null) {
		_g.setReserved("0","Zero");
	} else {
		_g.h["0"] = "Zero";
	}
	if(__map_reserved["1"] != null) {
		_g.setReserved("1","One");
	} else {
		_g.h["1"] = "One";
	}
	if(__map_reserved["2"] != null) {
		_g.setReserved("2","Two");
	} else {
		_g.h["2"] = "Two";
	}
	if(__map_reserved["3"] != null) {
		_g.setReserved("3","Three");
	} else {
		_g.h["3"] = "Three";
	}
	if(__map_reserved["4"] != null) {
		_g.setReserved("4","Four");
	} else {
		_g.h["4"] = "Four";
	}
	if(__map_reserved["5"] != null) {
		_g.setReserved("5","Five");
	} else {
		_g.h["5"] = "Five";
	}
	if(__map_reserved["6"] != null) {
		_g.setReserved("6","Six");
	} else {
		_g.h["6"] = "Six";
	}
	if(__map_reserved["7"] != null) {
		_g.setReserved("7","Seven");
	} else {
		_g.h["7"] = "Seven";
	}
	if(__map_reserved["8"] != null) {
		_g.setReserved("8","Eight");
	} else {
		_g.h["8"] = "Eight";
	}
	if(__map_reserved["9"] != null) {
		_g.setReserved("9","Nine");
	} else {
		_g.h["9"] = "Nine";
	}
	if(__map_reserved["!"] != null) {
		_g.setReserved("!","Bang");
	} else {
		_g.h["!"] = "Bang";
	}
	if(__map_reserved["\""] != null) {
		_g.setReserved("\"","DoubleQuote");
	} else {
		_g.h["\""] = "DoubleQuote";
	}
	if(__map_reserved["#"] != null) {
		_g.setReserved("#","Hash");
	} else {
		_g.h["#"] = "Hash";
	}
	if(__map_reserved["$"] != null) {
		_g.setReserved("$","Dollar");
	} else {
		_g.h["$"] = "Dollar";
	}
	if(__map_reserved["£"] != null) {
		_g.setReserved("£","Pound");
	} else {
		_g.h["£"] = "Pound";
	}
	if(__map_reserved["%"] != null) {
		_g.setReserved("%","Percent");
	} else {
		_g.h["%"] = "Percent";
	}
	if(__map_reserved["&"] != null) {
		_g.setReserved("&","Ampersand");
	} else {
		_g.h["&"] = "Ampersand";
	}
	if(__map_reserved["'"] != null) {
		_g.setReserved("'","Quote");
	} else {
		_g.h["'"] = "Quote";
	}
	if(__map_reserved["("] != null) {
		_g.setReserved("(","LeftParentheses");
	} else {
		_g.h["("] = "LeftParentheses";
	}
	if(__map_reserved[")"] != null) {
		_g.setReserved(")","RightParentheses");
	} else {
		_g.h[")"] = "RightParentheses";
	}
	if(__map_reserved["*"] != null) {
		_g.setReserved("*","Star");
	} else {
		_g.h["*"] = "Star";
	}
	if(__map_reserved["+"] != null) {
		_g.setReserved("+","Plus");
	} else {
		_g.h["+"] = "Plus";
	}
	if(__map_reserved[","] != null) {
		_g.setReserved(",","Comma");
	} else {
		_g.h[","] = "Comma";
	}
	if(__map_reserved["-"] != null) {
		_g.setReserved("-","Minus");
	} else {
		_g.h["-"] = "Minus";
	}
	if(__map_reserved["."] != null) {
		_g.setReserved(".","Dot");
	} else {
		_g.h["."] = "Dot";
	}
	if(__map_reserved["/"] != null) {
		_g.setReserved("/","ForwardSlash");
	} else {
		_g.h["/"] = "ForwardSlash";
	}
	if(__map_reserved[":"] != null) {
		_g.setReserved(":","Colon");
	} else {
		_g.h[":"] = "Colon";
	}
	if(__map_reserved[";"] != null) {
		_g.setReserved(";","SemiColon");
	} else {
		_g.h[";"] = "SemiColon";
	}
	if(__map_reserved["<"] != null) {
		_g.setReserved("<","LessThan");
	} else {
		_g.h["<"] = "LessThan";
	}
	if(__map_reserved["="] != null) {
		_g.setReserved("=","Equals");
	} else {
		_g.h["="] = "Equals";
	}
	if(__map_reserved[">"] != null) {
		_g.setReserved(">","GreaterThan");
	} else {
		_g.h[">"] = "GreaterThan";
	}
	if(__map_reserved["?"] != null) {
		_g.setReserved("?","QuestionMark");
	} else {
		_g.h["?"] = "QuestionMark";
	}
	if(__map_reserved["{"] != null) {
		_g.setReserved("{","LeftBrace");
	} else {
		_g.h["{"] = "LeftBrace";
	}
	if(__map_reserved["|"] != null) {
		_g.setReserved("|","Bar");
	} else {
		_g.h["|"] = "Bar";
	}
	if(__map_reserved["}"] != null) {
		_g.setReserved("}","RightBrace");
	} else {
		_g.h["}"] = "RightBrace";
	}
	if(__map_reserved["~"] != null) {
		_g.setReserved("~","Tilde");
	} else {
		_g.h["~"] = "Tilde";
	}
	if(__map_reserved["["] != null) {
		_g.setReserved("[","LeftSquareBracket");
	} else {
		_g.h["["] = "LeftSquareBracket";
	}
	if(__map_reserved["\\"] != null) {
		_g.setReserved("\\","BackwardSlash");
	} else {
		_g.h["\\"] = "BackwardSlash";
	}
	if(__map_reserved["]"] != null) {
		_g.setReserved("]","RightSquareBracket");
	} else {
		_g.h["]"] = "RightSquareBracket";
	}
	if(__map_reserved["^"] != null) {
		_g.setReserved("^","Caret");
	} else {
		_g.h["^"] = "Caret";
	}
	if(__map_reserved["_"] != null) {
		_g.setReserved("_","Underscore");
	} else {
		_g.h["_"] = "Underscore";
	}
	if(__map_reserved["@"] != null) {
		_g.setReserved("@","At");
	} else {
		_g.h["@"] = "At";
	}
	$r = _g;
	return $r;
}(this));
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=dts2hx.js.map